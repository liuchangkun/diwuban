# 泵组特性曲线拟合 - 核心策略选择与动态调整机制

## 📋 核心策略选择与动态调整机制

### 1. 缺失数据补齐策略智能选择

#### 🎯 补齐策略优先级

```
FFILL (前向填充) → MEAN (均值填充) → REG (回归补齐) → CURVE_ENHANCED (曲线增强)
```

#### 📊 智能选择决策树

```python
class DataCompletionStrategySelector:
    def select_optimal_strategy(self, missing_gap_hours: int, data_quality: float,
                              context_availability: bool, curve_availability: bool) -> str:
        """
        智能选择补齐策略

        参数:
            missing_gap_hours: 缺失时间跨度（小时）
            data_quality: 数据质量评分 (0-1)
            context_availability: 是否有上下文数据
            curve_availability: 是否有可用特性曲线
        """

        # 1. 短缺口（<2小时）：FFILL优先
        if missing_gap_hours <= 2 and context_availability:
            return "FFILL"

        # 2. 中等缺口（2-12小时）：MEAN策略
        elif missing_gap_hours <= 12 and data_quality > 0.7:
            return "MEAN"

        # 3. 长期缺口（>12小时）：REG回归
        elif missing_gap_hours > 12 and data_quality > 0.5:
            return "REG"

        # 4. 高级策略：CURVE_ENHANCED（当有拟合曲线时）
        elif curve_availability and data_quality > 0.6:
            return "CURVE_ENHANCED"

        # 5. 兜底策略：降级到MEAN
        else:
            return "MEAN"
```

### 2. 特性曲线拟合方法选择

#### 🎯 拟合算法优先级

```
神经网络 → 随机森林 → 高斯过程 → 多项式 → 样条 → 线性 → 默认曲线
```

#### 📊 多算法并行优化策略

```python
class MultiAlgorithmCurveFitter:
    def __init__(self):
        self.methods_priority = [
            ("neural_network", {"min_samples": 200, "r2_threshold": 0.90}),
            ("random_forest", {"min_samples": 100, "r2_threshold": 0.85}),
            ("gaussian_process", {"min_samples": 50, "r2_threshold": 0.80}),
            ("polynomial", {"min_samples": 30, "r2_threshold": 0.70}),
            ("spline", {"min_samples": 20, "r2_threshold": 0.60}),
            ("linear", {"min_samples": 10, "r2_threshold": 0.40})
        ]

    async def fit_all_algorithms_parallel(self, data: CurveData) -> Dict[str, FittingResult]:
        """并行执行所有适用算法"""
        tasks = []
        for method, criteria in self.methods_priority:
            if len(data) >= criteria["min_samples"]:
                task = self._fit_single_method(method, data)
                tasks.append((method, task))

        results = await asyncio.gather(*[task for _, task in tasks])
        return dict(zip([method for method, _ in tasks], results))
```

### 3. 动态精度调整机制

#### 🔄 实际运行数据诊断与重拟合

```python
class DynamicFittingAdjustment:
    async def diagnose_and_readjust(self, fitted_curve: FittingResult,
                                  station_id: str, curve_type: str) -> FittingResult:
        """
        通过实际运行数据诊断精度，如果过低则更改拟合方法再来一次
        """

        # 1. 获取最近7天实际运行数据
        recent_data = await self._get_recent_operation_data(station_id, days=7)

        if not recent_data:
            return fitted_curve  # 无数据时保持原结果

        # 2. 计算实际运行精度
        operational_accuracy = await self._calculate_operational_accuracy(
            fitted_curve, recent_data
        )

        self.logger.info(
            "curve.accuracy.diagnosis",
            station_id=station_id,
            curve_type=curve_type,
            operational_accuracy=operational_accuracy,
            threshold=0.7
        )

        # 3. 精度诊断：如果低于70%阈值，启动重拟合
        if operational_accuracy < 0.7:
            self.logger.warning(
                f"曲线精度过低({operational_accuracy:.2%})，启动动态调整重拟合"
            )

            # 4. 尝试不同拟合策略
            adjusted_curve = await self._try_alternative_methods(station_id, curve_type)

            # 5. 验证新拟合结果
            new_accuracy = await self._calculate_operational_accuracy(
                adjusted_curve, recent_data
            )

            # 6. 选择最优结果
            if new_accuracy > operational_accuracy:
                self.logger.info(
                    f"重拟合成功，精度提升: {operational_accuracy:.2%} → {new_accuracy:.2%}"
                )
                return adjusted_curve
            else:
                self.logger.warning(
                    f"重拟合未改善，保持原结果: {operational_accuracy:.2%}"
                )

        return fitted_curve

    async def _try_alternative_methods(self, station_id: str, curve_type: str) -> FittingResult:
        """尝试替代拟合方法"""

        alternative_strategies = [
            "ensemble_learning",      # 集成学习融合
            "parameter_optimization", # 参数优化重试
            "segmented_fitting",      # 分段拟合
            "robust_regression",      # 鲁棒回归
            "hybrid_method"           # 混合方法
        ]

        best_result = None
        best_score = 0

        for strategy in alternative_strategies:
            try:
                result = await self._apply_strategy(strategy, station_id, curve_type)
                score = await self._evaluate_strategy_score(result)

                if score > best_score:
                    best_score = score
                    best_result = result

            except Exception as e:
                self.logger.error(f"策略 {strategy} 失败: {e}")
                continue

        return best_result or self._get_default_curve(curve_type)
```

## 🎯 最佳实践与实施建议

### 1. 数据补齐策略实践

#### 🎯 优先级原则

- **优先使用CURVE_ENHANCED**：当有可靠特性曲线时，基于物理约束的补齐精度最高
- **动态质量门槛**：根据数据质量实时调整策略选择
- **补齐质量追踪**：记录每种策略的成功率，持续优化

#### 📊 具体实施框架

```python
class IntegratedCompletionFramework:
    def __init__(self):
        self.strategy_performance = {
            'FFILL': {'success_rate': 0.95, 'avg_confidence': 0.88},
            'MEAN': {'success_rate': 0.85, 'avg_confidence': 0.72},
            'REG': {'success_rate': 0.75, 'avg_confidence': 0.65},
            'CURVE_ENHANCED': {'success_rate': 0.92, 'avg_confidence': 0.89}
        }

    async def adaptive_completion(self, missing_data_context: Dict) -> str:
        """自适应补齐策略选择"""

        # 1. 环境评估
        context_score = self._evaluate_context(missing_data_context)

        # 2. 历史性能加权
        weighted_strategies = self._apply_historical_weights(context_score)

        # 3. 选择最优策略
        selected_strategy = max(weighted_strategies, key=weighted_strategies.get)

        return selected_strategy
```

### 2. 曲线拟合策略实践

#### 🎯 数据驱动选择

- **数据量大（>200样本）**: 优先神经网络和随机森林
- **数据量中等（50-200样本）**: 高斯过程和多项式拟合
- **数据量小（\<50样本）**: 样条和线性拟合
- **数据不足**: 使用默认理论曲线

#### 📊 质量阈值降级机制

```python
class QualityThresholdManager:
    quality_levels = {
        'excellent': {'r2': 0.90, 'rmse_max': 0.05, 'confidence': 0.95},
        'good': {'r2': 0.80, 'rmse_max': 0.10, 'confidence': 0.85},
        'acceptable': {'r2': 0.65, 'rmse_max': 0.20, 'confidence': 0.70},
        'poor': {'r2': 0.40, 'rmse_max': 0.35, 'confidence': 0.50}
    }

    def ensure_minimum_quality(self, fitting_result: FittingResult) -> bool:
        """确保最低质量标准"""
        return fitting_result.r2_score >= self.quality_levels['poor']['r2']
```

### 3. 动态调整优化实践

#### 🔄 实时监控与调整

```python
class RealTimeOptimizationMonitor:
    def __init__(self):
        self.performance_thresholds = {
            'accuracy_threshold': 0.70,  # 70%精度阈值
            'degradation_threshold': 0.05,  # 5%性能下降阈值
            'monitoring_window': 7  # 7天监控窗口
        }

    async def continuous_monitoring(self, station_id: str) -> None:
        """持续监控和优化"""

        while True:
            # 1. 定期评估曲线性能
            performance = await self._evaluate_curve_performance(station_id)

            # 2. 检测性能下降
            if performance['accuracy'] < self.performance_thresholds['accuracy_threshold']:
                # 3. 触发动态重拟合
                await self._trigger_dynamic_refitting(station_id, performance)

            # 4. 等待下一个监控周期
            await asyncio.sleep(3600)  # 1小时检查一次
```

#### 🎯 精度提升目标

- **扬程RMSE**: 从4.0m降低到1.5m（提升62.5%）
- **效率MAE**: 从8%降低到3%（提升62.5%）
- **流量误差**: 从12%降低到4%（提升66.7%）
- **整体精度**: 综合精度提升60%以上

### 4. 系统架构考虑

#### 🎯 统一的策略选择接口

```python
class UnifiedStrategySelector:
    async def select_completion_strategy(self, context: CompletionContext) -> str:
        """选择最优补齐策略"""
        pass

    async def select_fitting_algorithm(self, data: CurveData) -> str:
        """选择最优拟合算法"""
        pass

    async def optimize_all_methods(self, optimization_target: str) -> OptimizationPlan:
        """制定全方位优化计划"""
        pass
```

#### 📊 并行计算优化

- **并行计算**: 充分利用多核CPU，提高优化效率
- **集成学习**: 融合多种算法优势，提高预测精度
- **在线校准**: 结合RLS算法实现参数自适应更新

#### 🛡️ 鲁棒性保证

- **降级机制**: 通过降级机制确保系统的鲁棒性
- **多曲线验证**: H-Q、η-Q、P-Q曲线相互验证
- **物理约束**: 确保所有结果符合物理定律

### 5. 监控与日志

#### 📊 关键指标监控

```python
class PerformanceMetrics:
    key_metrics = {
        'completion_success_rate': 0.95,  # 补齐成功率
        'fitting_accuracy': 0.85,         # 拟合精度
        'dynamic_adjustment_frequency': 0.1, # 动态调整频率
        'system_response_time': 30,       # 系统响应时间(秒)
        'overall_improvement': 0.6        # 整体改善幅度
    }
```

这样的设计既保证了系统的鲁棒性（通过降级机制），又充分发挥了各种算法的优势（通过并行优化和智能融合），最终实现**60%以上的精度提升**目标。

这个核心策略选择与动态调整机制模块提供了：

1. **智能策略选择** - 根据数据特征自动选择最优补齐和拟合策略
1. **并行算法优化** - 同时运行多种算法并选择最优结果
1. **动态精度调整** - 基于实际运行数据诊断和重拟合
1. **实时监控机制** - 持续监控性能并触发自动优化
1. **质量控制体系** - 确保拟合结果达到工程应用标准

通过这些机制，系统能够自适应地维持和改进拟合质量，实现真正的工程可用性。
