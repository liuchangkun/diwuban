# 泵组特性曲线拟合 - 泵组协调特性曲线体系定义

## 📊 F类：泵组协调特性曲线体系 (新增20种)

### 核心泵组特性曲线

**64. 泵组总功率-总流量曲线 (P_total-Q_total)**
- X轴：Σ(pump_flow_rate) (m3/H) 
- Y轴：Σ(pump_active_power) (kW)
- 用途：泵组功耗预测和节能控制
- 拟合变量：pump_flow_rate, pump_active_power

**65. 泵组平均效率-负载率曲线 (η_avg-Load)**
- X轴：负载率 = 当前总流量/设计总流量 (%)
- Y轴：Σ(pump_efficiency×pump_flow_rate)/Σ(pump_flow_rate) (%)
- 用途：部分负荷效率优化
- 拟合变量：pump_flow_rate, pump_efficiency

**66. 泵组启停损失曲线 (Start_Loss-Freq)**
- X轴：启停频次 (次/天)
- Y轴：计算损失功率 = 启动功率×启动时间×频次 (kWh)
- 用途：优化启停策略
- 拟合变量：pump_active_power, pump_frequency

**67. 泵组不平衡系数曲线 (Imbalance-Q_ratio)**
- X轴：流量分配比 = max(pump_flow_rate)/min(pump_flow_rate)
- Y轴：效率损失 = η_ideal - η_actual (%)
- 用途：流量均衡控制
- 拟合变量：pump_flow_rate (所有泵), pump_efficiency

**68. 泵组协调系数曲线 (Coord-N_pumps)**
- X轴：运行泵数量
- Y轴：协调效率 = η_group/η_single_avg (%)
- 用途：最优泵数选择
- 拟合变量：pump_efficiency, pump_flow_rate

**69. 泵组频率分布效率曲线 (η-f_distribution)**
- X轴：频率分布标准差 = std(pump_frequency_1, pump_frequency_2, ...)
- Y轴：泵组总效率 (%)
- 用途：频率协调优化
- 拟合变量：pump_frequency (所有泵), pump_efficiency

**70. 泵组压力分担曲线 (P_share-H_target)**
- X轴：目标扬程 (M)
- Y轴：各泵压力分担比 = pump_head_i/Σ(pump_head) (%)
- 用途：压力均衡控制
- 拟合变量：pump_head, main_pipeline_outlet_pressure

**71. 泵组磨损均衡曲线 (Wear-Runtime)**
- X轴：累计运行时间比 = runtime_i/avg(runtime)
- Y轴：磨损指标 = f(振动，温度，效率下降)
- 用途：磨损均衡调度
- 拟合变量：pump_vibration_sensor_*, pump_temperature_sensor_*, pump_efficiency

**72. 泵组响应速度曲线 (Response-Load_change)**
- X轴：负载变化率 (%/min)
- Y轴：系统响应时间 (s)
- 用途：动态响应优化
- 拟合变量：pump_frequency, pump_flow_rate

**73. 泵组稳定性曲线 (Stability-Operating_point)**
- X轴：工作点偏离度 = |Q_actual-Q_BEP|/Q_BEP (%)
- Y轴：系统稳定性指标 = 1/std(压力波动)
- 用途：稳定运行区间
- 拟合变量：pump_flow_rate, pump_outlet_pressure

### 其他高级泵组曲线 (74-83)

**74. 泵组节能潜力曲线 (Energy_saving-Load)**
- X轴：当前负载率 (%)
- Y轴：节能潜力 = (P_current - P_optimal)/P_current (%)
- 用途：识别节能机会
- 拟合变量：pump_active_power, pump_efficiency, pump_flow_rate

**75. 泵组冗余度曲线 (Redundancy-Failure_rate)**
- X轴：设备故障率 (次/年)
- Y轴：系统可靠性 = 1 - P(系统故障)
- 用途：冗余配置优化
- 拟合变量：pump状态历史数据, 维护记录

**76. 泵组切换损失曲线 (Switch_Loss-Frequency)**
- X轴：泵切换频次 (次/小时)
- Y轴：切换能耗损失 (kWh)
- 用途：切换策略优化
- 拟合变量：pump_active_power, pump_frequency, 启停记录

**77. 泵组变频协调曲线 (VFD_Coord-Load_distribution)**
- X轴：负载分配不均匀度 = std(各泵负载率)
- Y轴：变频器协调效率 (%)
- 用途：变频器协调控制
- 拟合变量：pump_frequency (所有泵), pump_active_power

**78. 泵组预测精度曲线 (Prediction_Accuracy-Horizon)**
- X轴：预测时间窗口 (小时)
- Y轴：负荷预测精度 (%)
- 用途：预测模型优化
- 拟合变量：历史负荷数据, 预测结果对比

**79. 泵组维护窗口曲线 (Maintenance_Window-Performance)**
- X轴：距离上次维护时间 (天)
- Y轴：性能衰减指标 = (η_initial - η_current)/η_initial (%)
- 用途：预测性维护
- 拟合变量：pump_efficiency, pump_vibration_sensor_*, pump_temperature_sensor_*

**80. 泵组环境适应曲线 (Environment_Adapt-Conditions)**
- X轴：环境参数组合 = f(water_temperature, 大气压力, 湿度)
- Y轴：性能修正系数
- 用途：环境补偿控制
- 拟合变量：water_temperature, pump_efficiency, 外部环境数据

**81. 泵组智能学习曲线 (Learning-Experience)**
- X轴：运行经验值 = 累计运行小时数
- Y轴：优化算法精度提升 (%)
- 用途：自适应优化
- 拟合变量：优化历史记录, 精度改善数据

**82. 泵组故障传播曲线 (Fault_Propagation-Severity)**
- X轴：单泵故障严重程度
- Y轴：对泵组整体影响程度 (%)
- 用途：故障隔离策略
- 拟合变量：故障历史数据, 系统响应记录

**83. 泵组经济运行曲线 (Economic_Operation-Cost)**
- X轴：运行成本 = 电费 + 维护费 + 折旧费 (元/m³)
- Y轴：经济效益指标 = 收益/成本
- 用途：经济性优化
- 拟合变量：pump_kwh, 维护成本, 设备折旧

## 🛡️ 拟合降级策略体系

### 多层次降级策略

```python
# app/services/curve_fitting_fallback.py

from enum import Enum
from typing import List, Dict, Optional, Union
import numpy as np
from dataclasses import dataclass

class FittingMethod(Enum):
    NEURAL_NETWORK = "neural_network"
    RANDOM_FOREST = "random_forest" 
    GRADIENT_BOOSTING = "gradient_boosting"
    POLYNOMIAL = "polynomial"
    SPLINE = "spline"
    LINEAR = "linear"
    DEFAULT_CURVE = "default_curve"

class CurveFittingFallbackStrategy:
    """曲线拟合降级策略管理器"""
    
    def __init__(self):
        self.fallback_chain = {
            "pump_group_curves": [
                FittingMethod.NEURAL_NETWORK,
                FittingMethod.RANDOM_FOREST,
                FittingMethod.POLYNOMIAL,
                FittingMethod.LINEAR,
                FittingMethod.DEFAULT_CURVE
            ],
            "basic_pump_curves": [
                FittingMethod.GRADIENT_BOOSTING,
                FittingMethod.SPLINE,
                FittingMethod.POLYNOMIAL,
                FittingMethod.LINEAR,
                FittingMethod.DEFAULT_CURVE
            ]
        }
        self.quality_thresholds = {
            "excellent": {"r2": 0.90, "rmse_threshold": 0.05},
            "good": {"r2": 0.80, "rmse_threshold": 0.10},
            "acceptable": {"r2": 0.65, "rmse_threshold": 0.20},
            "poor": {"r2": 0.40, "rmse_threshold": 0.35}
        }
    
    async def fit_with_fallback(self, curve_type: str, x_data: np.ndarray, y_data: np.ndarray) -> Dict:
        """带降级策略的曲线拟合"""
        
        # 数据质量预检
        data_quality = self._assess_data_quality(x_data, y_data)
        
        # 选择降级链
        category = "pump_group_curves" if "group" in curve_type else "basic_pump_curves"
        methods = self.fallback_chain[category]
        
        # 依次尝试拟合方法
        for i, method in enumerate(methods):
            try:
                result = await self._fit_with_method(method, x_data, y_data)
                quality = self._evaluate_quality(result, x_data, y_data)
                
                if self._is_quality_acceptable(quality, method):
                    return {
                        "model": result,
                        "method": method,
                        "quality": quality,
                        "fallback_level": i
                    }
            except Exception as e:
                continue
        
        # 使用默认曲线
        return {
            "model": self._get_default_curve(curve_type),
            "method": FittingMethod.DEFAULT_CURVE,
            "fallback_level": 3
        }
    
    def _assess_data_quality(self, x_data: np.ndarray, y_data: np.ndarray) -> float:
        """评估数据质量"""
        quality = 1.0
        
        # 样本数量
        if len(x_data) < 50:
            quality *= 0.7
        
        # 数据分布
        if np.std(x_data) == 0:
            quality *= 0.1
            
        # 异常值比例
        q75, q25 = np.percentile(y_data, [75, 25])
        iqr = q75 - q25
        outliers = np.sum((y_data < (q25 - 1.5 * iqr)) | (y_data > (q75 + 1.5 * iqr)))
        outlier_ratio = outliers / len(y_data)
        quality *= (1 - outlier_ratio)
        
        return max(0.0, min(1.0, quality))

    def _is_quality_acceptable(self, quality_metrics: Dict, method: FittingMethod) -> bool:
        """判断质量是否可接受"""
        
        method_requirements = {
            FittingMethod.NEURAL_NETWORK: self.quality_thresholds["excellent"],
            FittingMethod.RANDOM_FOREST: self.quality_thresholds["good"],
            FittingMethod.GRADIENT_BOOSTING: self.quality_thresholds["good"],
            FittingMethod.POLYNOMIAL: self.quality_thresholds["acceptable"],
            FittingMethod.SPLINE: self.quality_thresholds["acceptable"],
            FittingMethod.LINEAR: self.quality_thresholds["poor"],
            FittingMethod.DEFAULT_CURVE: {"r2": 0.0, "rmse_threshold": float('inf')}
        }
        
        requirements = method_requirements.get(method, self.quality_thresholds["poor"])
        
        return (quality_metrics.get('r2', 0) >= requirements['r2'] and 
                quality_metrics.get('rmse', float('inf')) <= requirements['rmse_threshold'])

    async def _fit_with_method(self, method: FittingMethod, x_data: np.ndarray, y_data: np.ndarray):
        """使用指定方法拟合"""
        
        if method == FittingMethod.NEURAL_NETWORK:
            return await self._neural_network_fitting(x_data, y_data)
        elif method == FittingMethod.RANDOM_FOREST:
            return await self._random_forest_fitting(x_data, y_data)
        elif method == FittingMethod.GRADIENT_BOOSTING:
            return await self._gradient_boosting_fitting(x_data, y_data)
        elif method == FittingMethod.POLYNOMIAL:
            return await self._polynomial_fitting(x_data, y_data)
        elif method == FittingMethod.SPLINE:
            return await self._spline_fitting(x_data, y_data)
        elif method == FittingMethod.LINEAR:
            return await self._linear_fitting(x_data, y_data)
        else:
            return self._get_default_curve(curve_type)

    def _get_default_curve(self, curve_type: str):
        """获取默认理论曲线"""
        
        default_curves = {
            "HQ": lambda Q: 45 - 0.0001 * Q**2,  # 典型扬程曲线
            "EtaQ": lambda Q: 0.8 * (1 - ((Q - 100) / 100)**2),  # 典型效率曲线  
            "PQ": lambda Q: 0.0001 * Q**3 + 0.01 * Q**2 + 0.5 * Q + 5,  # 典型功率曲线
            "pump_group_power": lambda Q_total: sum([self._single_pump_power(Q_total/n) for n in range(1, 5)]),
            "pump_group_efficiency": lambda load_rate: 0.85 * (1 - (load_rate - 0.8)**2) if 0.5 <= load_rate <= 1.2 else 0.5
        }
        
        return default_curves.get(curve_type, lambda x: 0)
```

### 智能数据筛选

**多层次降级策略**：
1. **神经网络拟合** → 2. **随机森林** → 3. **多项式拟合** → 4. **线性拟合** → 5. **默认曲线**

**智能数据筛选**：
- 排除FFILL补齐数据（连续相同值检测）
- 排除MEAN补齐数据（统计异常检测）
- 排除REG补齐数据（过度平滑检测）
- 仅使用原始高质量数据进行拟合

**质量评估标准**：
- R² > 0.90 (优秀) > 0.80 (良好) > 0.65 (可接受) > 0.40 (差)
- 物理约束验证：效率0-100%，协调系数0.5-1.5，功率>0等
- 样本数量要求：最少20个有效数据点

### 数据筛选实现

```python
class IntelligentDataSelector:
    """智能数据筛选器"""
    
    def __init__(self):
        self.quality_filters = {
            'remove_filled_data': self._remove_filled_data,
            'remove_outliers': self._remove_outliers,
            'ensure_steady_state': self._ensure_steady_state,
            'validate_physical_range': self._validate_physical_range
        }
    
    async def select_high_quality_data(self, station_id: str, device_id: str, 
                                     curve_type: str, days: int = 30) -> CurveData:
        """选择高质量数据用于曲线拟合"""
        
        # 1. 获取原始数据
        raw_data = await self._fetch_raw_data(station_id, device_id, days)
        
        # 2. 应用质量过滤器
        filtered_data = raw_data
        for filter_name, filter_func in self.quality_filters.items():
            filtered_data = await filter_func(filtered_data, curve_type)
            self.logger.info(f"过滤器 {filter_name} 保留数据: {len(filtered_data)}")
        
        # 3. 验证最终数据质量
        if len(filtered_data) < 20:
            self.logger.warning(f"数据量不足，仅{len(filtered_data)}个样本")
            return self._get_extended_data(station_id, device_id, curve_type, days=60)
        
        return CurveData(
            x_data=filtered_data['x_values'],
            y_data=filtered_data['y_values'],
            timestamps=filtered_data['timestamps'],
            quality_score=self._calculate_data_quality_score(filtered_data)
        )
    
    async def _remove_filled_data(self, data: Dict, curve_type: str) -> Dict:
        """移除补齐数据"""
        
        # 检测FFILL补齐：连续相同值
        ffill_mask = self._detect_ffill_pattern(data['y_values'])
        
        # 检测MEAN补齐：统计异常
        mean_mask = self._detect_mean_pattern(data['y_values'])
        
        # 检测REG补齐：过度平滑
        reg_mask = self._detect_regression_pattern(data['y_values'])
        
        # 合并掩码，保留原始数据
        valid_mask = ~(ffill_mask | mean_mask | reg_mask)
        
        return {
            'x_values': data['x_values'][valid_mask],
            'y_values': data['y_values'][valid_mask], 
            'timestamps': data['timestamps'][valid_mask]
        }
    
    def _detect_ffill_pattern(self, y_values: np.ndarray) -> np.ndarray:
        """检测前向填充模式"""
        # 检测连续相同值（FFILL特征）
        consecutive_same = np.zeros(len(y_values), dtype=bool)
        
        for i in range(1, len(y_values)):
            if abs(y_values[i] - y_values[i-1]) < 1e-6:  # 几乎相同
                consecutive_same[i] = True
                # 向前传播，标记连续段
                j = i - 1
                while j >= 0 and abs(y_values[j] - y_values[i]) < 1e-6:
                    consecutive_same[j] = True
                    j -= 1
        
        return consecutive_same
    
    def _detect_mean_pattern(self, y_values: np.ndarray) -> np.ndarray:
        """检测均值填充模式"""
        # 检测是否为局部均值（MEAN特征）
        mean_filled = np.zeros(len(y_values), dtype=bool)
        
        window = 5  # 检查窗口
        for i in range(window, len(y_values) - window):
            local_window = y_values[i-window:i+window+1]
            local_mean = np.mean(local_window[local_window != y_values[i]])
            
            # 如果值接近局部均值，可能是MEAN填充
            if len(local_window) > 1 and abs(y_values[i] - local_mean) < 0.01 * local_mean:
                mean_filled[i] = True
        
        return mean_filled
    
    def _detect_regression_pattern(self, y_values: np.ndarray) -> np.ndarray:
        """检测回归填充模式"""
        # 检测过度平滑（REG特征）
        reg_filled = np.zeros(len(y_values), dtype=bool)
        
        # 计算二阶差分，检测异常平滑
        if len(y_values) > 2:
            second_diff = np.diff(y_values, n=2)
            smooth_threshold = np.std(second_diff) * 0.1
            
            for i in range(1, len(y_values) - 1):
                if abs(second_diff[i-1]) < smooth_threshold:
                    reg_filled[i] = True
        
        return reg_filled
```

### 曲线质量验证

```python
class CurveQualityValidator:
    """曲线质量验证器"""
    
    def __init__(self):
        self.validation_criteria = {
            'r2_threshold': {'excellent': 0.90, 'good': 0.80, 'acceptable': 0.65},
            'rmse_threshold': {'excellent': 0.05, 'good': 0.10, 'acceptable': 0.20},
            'physical_constraints': True,
            'cross_validation': True
        }
    
    async def comprehensive_validation(self, fitted_curve: FittingResult, 
                                    validation_data: List[DataPoint]) -> ValidationReport:
        """综合验证拟合曲线"""
        
        # 1. 统计指标验证
        r2_score = self._calculate_r2(fitted_curve, validation_data)
        rmse = self._calculate_rmse(fitted_curve, validation_data)
        mae = self._calculate_mae(fitted_curve, validation_data)
        
        # 2. 物理意义验证
        physics_check = self._validate_physics_constraints(fitted_curve)
        
        # 3. 实际运行验证（使用最近历史数据）
        recent_data = await self._get_recent_operation_data(device_id, days=7)
        operational_accuracy = self._validate_against_operation(fitted_curve, recent_data)
        
        # 4. 交叉验证
        cv_scores = await self._cross_validation(fitting_data, k=5)
        
        return ValidationReport(
            r2=r2_score,
            rmse=rmse, 
            mae=mae,
            physics_valid=physics_check.is_valid,
            operational_accuracy=operational_accuracy,
            cv_mean=cv_scores.mean(),
            quality_grade=self._assign_quality_grade(r2_score, rmse),
            recommendation=self._generate_recommendation(r2_score, rmse, physics_check)
        )
    
    def _assign_quality_grade(self, r2: float, rmse: float) -> str:
        """分配质量等级"""
        if r2 >= 0.90 and rmse <= 0.05:
            return 'A+级 - 高精度工程级'
        elif r2 >= 0.80 and rmse <= 0.10:
            return 'A级 - 工程合格'
        elif r2 >= 0.65 and rmse <= 0.20:
            return 'B级 - 基本可用'
        elif r2 >= 0.40 and rmse <= 0.35:
            return 'C级 - 需要改进'
        else:
            return 'D级 - 不建议使用'
```

这个泵组协调特性曲线体系定义模块提供了：

1. **完整的F类泵组协调曲线** - 20种新增的泵组特性曲线定义（64-83）
2. **多层次降级策略** - 确保拟合的鲁棒性和可靠性
3. **智能数据筛选** - 排除补齐数据，使用高质量原始数据
4. **质量验证体系** - 多维度验证拟合结果的工程可用性

通过这些完整的曲线体系和质量保证机制，系统能够实现60%以上的精度提升目标。