# æ³µç»„ç‰¹æ€§æ›²çº¿æ‹Ÿåˆ - æ³µç»„åè°ƒç‰¹æ€§æ›²çº¿ä½“ç³»å®šä¹‰

## ğŸ“Š Fç±»ï¼šæ³µç»„åè°ƒç‰¹æ€§æ›²çº¿ä½“ç³» (æ–°å¢20ç§)

### æ ¸å¿ƒæ³µç»„ç‰¹æ€§æ›²çº¿

**64. æ³µç»„æ€»åŠŸç‡-æ€»æµé‡æ›²çº¿ (P_total-Q_total)**
- Xè½´ï¼šÎ£(pump_flow_rate) (m3/H) 
- Yè½´ï¼šÎ£(pump_active_power) (kW)
- ç”¨é€”ï¼šæ³µç»„åŠŸè€—é¢„æµ‹å’ŒèŠ‚èƒ½æ§åˆ¶
- æ‹Ÿåˆå˜é‡ï¼špump_flow_rate, pump_active_power

**65. æ³µç»„å¹³å‡æ•ˆç‡-è´Ÿè½½ç‡æ›²çº¿ (Î·_avg-Load)**
- Xè½´ï¼šè´Ÿè½½ç‡ = å½“å‰æ€»æµé‡/è®¾è®¡æ€»æµé‡ (%)
- Yè½´ï¼šÎ£(pump_efficiencyÃ—pump_flow_rate)/Î£(pump_flow_rate) (%)
- ç”¨é€”ï¼šéƒ¨åˆ†è´Ÿè·æ•ˆç‡ä¼˜åŒ–
- æ‹Ÿåˆå˜é‡ï¼špump_flow_rate, pump_efficiency

**66. æ³µç»„å¯åœæŸå¤±æ›²çº¿ (Start_Loss-Freq)**
- Xè½´ï¼šå¯åœé¢‘æ¬¡ (æ¬¡/å¤©)
- Yè½´ï¼šè®¡ç®—æŸå¤±åŠŸç‡ = å¯åŠ¨åŠŸç‡Ã—å¯åŠ¨æ—¶é—´Ã—é¢‘æ¬¡ (kWh)
- ç”¨é€”ï¼šä¼˜åŒ–å¯åœç­–ç•¥
- æ‹Ÿåˆå˜é‡ï¼špump_active_power, pump_frequency

**67. æ³µç»„ä¸å¹³è¡¡ç³»æ•°æ›²çº¿ (Imbalance-Q_ratio)**
- Xè½´ï¼šæµé‡åˆ†é…æ¯” = max(pump_flow_rate)/min(pump_flow_rate)
- Yè½´ï¼šæ•ˆç‡æŸå¤± = Î·_ideal - Î·_actual (%)
- ç”¨é€”ï¼šæµé‡å‡è¡¡æ§åˆ¶
- æ‹Ÿåˆå˜é‡ï¼špump_flow_rate (æ‰€æœ‰æ³µ), pump_efficiency

**68. æ³µç»„åè°ƒç³»æ•°æ›²çº¿ (Coord-N_pumps)**
- Xè½´ï¼šè¿è¡Œæ³µæ•°é‡
- Yè½´ï¼šåè°ƒæ•ˆç‡ = Î·_group/Î·_single_avg (%)
- ç”¨é€”ï¼šæœ€ä¼˜æ³µæ•°é€‰æ‹©
- æ‹Ÿåˆå˜é‡ï¼špump_efficiency, pump_flow_rate

**69. æ³µç»„é¢‘ç‡åˆ†å¸ƒæ•ˆç‡æ›²çº¿ (Î·-f_distribution)**
- Xè½´ï¼šé¢‘ç‡åˆ†å¸ƒæ ‡å‡†å·® = std(pump_frequency_1, pump_frequency_2, ...)
- Yè½´ï¼šæ³µç»„æ€»æ•ˆç‡ (%)
- ç”¨é€”ï¼šé¢‘ç‡åè°ƒä¼˜åŒ–
- æ‹Ÿåˆå˜é‡ï¼špump_frequency (æ‰€æœ‰æ³µ), pump_efficiency

**70. æ³µç»„å‹åŠ›åˆ†æ‹…æ›²çº¿ (P_share-H_target)**
- Xè½´ï¼šç›®æ ‡æ‰¬ç¨‹ (M)
- Yè½´ï¼šå„æ³µå‹åŠ›åˆ†æ‹…æ¯” = pump_head_i/Î£(pump_head) (%)
- ç”¨é€”ï¼šå‹åŠ›å‡è¡¡æ§åˆ¶
- æ‹Ÿåˆå˜é‡ï¼špump_head, main_pipeline_outlet_pressure

**71. æ³µç»„ç£¨æŸå‡è¡¡æ›²çº¿ (Wear-Runtime)**
- Xè½´ï¼šç´¯è®¡è¿è¡Œæ—¶é—´æ¯” = runtime_i/avg(runtime)
- Yè½´ï¼šç£¨æŸæŒ‡æ ‡ = f(æŒ¯åŠ¨ï¼Œæ¸©åº¦ï¼Œæ•ˆç‡ä¸‹é™)
- ç”¨é€”ï¼šç£¨æŸå‡è¡¡è°ƒåº¦
- æ‹Ÿåˆå˜é‡ï¼špump_vibration_sensor_*, pump_temperature_sensor_*, pump_efficiency

**72. æ³µç»„å“åº”é€Ÿåº¦æ›²çº¿ (Response-Load_change)**
- Xè½´ï¼šè´Ÿè½½å˜åŒ–ç‡ (%/min)
- Yè½´ï¼šç³»ç»Ÿå“åº”æ—¶é—´ (s)
- ç”¨é€”ï¼šåŠ¨æ€å“åº”ä¼˜åŒ–
- æ‹Ÿåˆå˜é‡ï¼špump_frequency, pump_flow_rate

**73. æ³µç»„ç¨³å®šæ€§æ›²çº¿ (Stability-Operating_point)**
- Xè½´ï¼šå·¥ä½œç‚¹åç¦»åº¦ = |Q_actual-Q_BEP|/Q_BEP (%)
- Yè½´ï¼šç³»ç»Ÿç¨³å®šæ€§æŒ‡æ ‡ = 1/std(å‹åŠ›æ³¢åŠ¨)
- ç”¨é€”ï¼šç¨³å®šè¿è¡ŒåŒºé—´
- æ‹Ÿåˆå˜é‡ï¼špump_flow_rate, pump_outlet_pressure

### å…¶ä»–é«˜çº§æ³µç»„æ›²çº¿ (74-83)

**74. æ³µç»„èŠ‚èƒ½æ½œåŠ›æ›²çº¿ (Energy_saving-Load)**
- Xè½´ï¼šå½“å‰è´Ÿè½½ç‡ (%)
- Yè½´ï¼šèŠ‚èƒ½æ½œåŠ› = (P_current - P_optimal)/P_current (%)
- ç”¨é€”ï¼šè¯†åˆ«èŠ‚èƒ½æœºä¼š
- æ‹Ÿåˆå˜é‡ï¼špump_active_power, pump_efficiency, pump_flow_rate

**75. æ³µç»„å†—ä½™åº¦æ›²çº¿ (Redundancy-Failure_rate)**
- Xè½´ï¼šè®¾å¤‡æ•…éšœç‡ (æ¬¡/å¹´)
- Yè½´ï¼šç³»ç»Ÿå¯é æ€§ = 1 - P(ç³»ç»Ÿæ•…éšœ)
- ç”¨é€”ï¼šå†—ä½™é…ç½®ä¼˜åŒ–
- æ‹Ÿåˆå˜é‡ï¼špumpçŠ¶æ€å†å²æ•°æ®, ç»´æŠ¤è®°å½•

**76. æ³µç»„åˆ‡æ¢æŸå¤±æ›²çº¿ (Switch_Loss-Frequency)**
- Xè½´ï¼šæ³µåˆ‡æ¢é¢‘æ¬¡ (æ¬¡/å°æ—¶)
- Yè½´ï¼šåˆ‡æ¢èƒ½è€—æŸå¤± (kWh)
- ç”¨é€”ï¼šåˆ‡æ¢ç­–ç•¥ä¼˜åŒ–
- æ‹Ÿåˆå˜é‡ï¼špump_active_power, pump_frequency, å¯åœè®°å½•

**77. æ³µç»„å˜é¢‘åè°ƒæ›²çº¿ (VFD_Coord-Load_distribution)**
- Xè½´ï¼šè´Ÿè½½åˆ†é…ä¸å‡åŒ€åº¦ = std(å„æ³µè´Ÿè½½ç‡)
- Yè½´ï¼šå˜é¢‘å™¨åè°ƒæ•ˆç‡ (%)
- ç”¨é€”ï¼šå˜é¢‘å™¨åè°ƒæ§åˆ¶
- æ‹Ÿåˆå˜é‡ï¼špump_frequency (æ‰€æœ‰æ³µ), pump_active_power

**78. æ³µç»„é¢„æµ‹ç²¾åº¦æ›²çº¿ (Prediction_Accuracy-Horizon)**
- Xè½´ï¼šé¢„æµ‹æ—¶é—´çª—å£ (å°æ—¶)
- Yè½´ï¼šè´Ÿè·é¢„æµ‹ç²¾åº¦ (%)
- ç”¨é€”ï¼šé¢„æµ‹æ¨¡å‹ä¼˜åŒ–
- æ‹Ÿåˆå˜é‡ï¼šå†å²è´Ÿè·æ•°æ®, é¢„æµ‹ç»“æœå¯¹æ¯”

**79. æ³µç»„ç»´æŠ¤çª—å£æ›²çº¿ (Maintenance_Window-Performance)**
- Xè½´ï¼šè·ç¦»ä¸Šæ¬¡ç»´æŠ¤æ—¶é—´ (å¤©)
- Yè½´ï¼šæ€§èƒ½è¡°å‡æŒ‡æ ‡ = (Î·_initial - Î·_current)/Î·_initial (%)
- ç”¨é€”ï¼šé¢„æµ‹æ€§ç»´æŠ¤
- æ‹Ÿåˆå˜é‡ï¼špump_efficiency, pump_vibration_sensor_*, pump_temperature_sensor_*

**80. æ³µç»„ç¯å¢ƒé€‚åº”æ›²çº¿ (Environment_Adapt-Conditions)**
- Xè½´ï¼šç¯å¢ƒå‚æ•°ç»„åˆ = f(water_temperature, å¤§æ°”å‹åŠ›, æ¹¿åº¦)
- Yè½´ï¼šæ€§èƒ½ä¿®æ­£ç³»æ•°
- ç”¨é€”ï¼šç¯å¢ƒè¡¥å¿æ§åˆ¶
- æ‹Ÿåˆå˜é‡ï¼šwater_temperature, pump_efficiency, å¤–éƒ¨ç¯å¢ƒæ•°æ®

**81. æ³µç»„æ™ºèƒ½å­¦ä¹ æ›²çº¿ (Learning-Experience)**
- Xè½´ï¼šè¿è¡Œç»éªŒå€¼ = ç´¯è®¡è¿è¡Œå°æ—¶æ•°
- Yè½´ï¼šä¼˜åŒ–ç®—æ³•ç²¾åº¦æå‡ (%)
- ç”¨é€”ï¼šè‡ªé€‚åº”ä¼˜åŒ–
- æ‹Ÿåˆå˜é‡ï¼šä¼˜åŒ–å†å²è®°å½•, ç²¾åº¦æ”¹å–„æ•°æ®

**82. æ³µç»„æ•…éšœä¼ æ’­æ›²çº¿ (Fault_Propagation-Severity)**
- Xè½´ï¼šå•æ³µæ•…éšœä¸¥é‡ç¨‹åº¦
- Yè½´ï¼šå¯¹æ³µç»„æ•´ä½“å½±å“ç¨‹åº¦ (%)
- ç”¨é€”ï¼šæ•…éšœéš”ç¦»ç­–ç•¥
- æ‹Ÿåˆå˜é‡ï¼šæ•…éšœå†å²æ•°æ®, ç³»ç»Ÿå“åº”è®°å½•

**83. æ³µç»„ç»æµè¿è¡Œæ›²çº¿ (Economic_Operation-Cost)**
- Xè½´ï¼šè¿è¡Œæˆæœ¬ = ç”µè´¹ + ç»´æŠ¤è´¹ + æŠ˜æ—§è´¹ (å…ƒ/mÂ³)
- Yè½´ï¼šç»æµæ•ˆç›ŠæŒ‡æ ‡ = æ”¶ç›Š/æˆæœ¬
- ç”¨é€”ï¼šç»æµæ€§ä¼˜åŒ–
- æ‹Ÿåˆå˜é‡ï¼špump_kwh, ç»´æŠ¤æˆæœ¬, è®¾å¤‡æŠ˜æ—§

## ğŸ›¡ï¸ æ‹Ÿåˆé™çº§ç­–ç•¥ä½“ç³»

### å¤šå±‚æ¬¡é™çº§ç­–ç•¥

```python
# app/services/curve_fitting_fallback.py

from enum import Enum
from typing import List, Dict, Optional, Union
import numpy as np
from dataclasses import dataclass

class FittingMethod(Enum):
    NEURAL_NETWORK = "neural_network"
    RANDOM_FOREST = "random_forest" 
    GRADIENT_BOOSTING = "gradient_boosting"
    POLYNOMIAL = "polynomial"
    SPLINE = "spline"
    LINEAR = "linear"
    DEFAULT_CURVE = "default_curve"

class CurveFittingFallbackStrategy:
    """æ›²çº¿æ‹Ÿåˆé™çº§ç­–ç•¥ç®¡ç†å™¨"""
    
    def __init__(self):
        self.fallback_chain = {
            "pump_group_curves": [
                FittingMethod.NEURAL_NETWORK,
                FittingMethod.RANDOM_FOREST,
                FittingMethod.POLYNOMIAL,
                FittingMethod.LINEAR,
                FittingMethod.DEFAULT_CURVE
            ],
            "basic_pump_curves": [
                FittingMethod.GRADIENT_BOOSTING,
                FittingMethod.SPLINE,
                FittingMethod.POLYNOMIAL,
                FittingMethod.LINEAR,
                FittingMethod.DEFAULT_CURVE
            ]
        }
        self.quality_thresholds = {
            "excellent": {"r2": 0.90, "rmse_threshold": 0.05},
            "good": {"r2": 0.80, "rmse_threshold": 0.10},
            "acceptable": {"r2": 0.65, "rmse_threshold": 0.20},
            "poor": {"r2": 0.40, "rmse_threshold": 0.35}
        }
    
    async def fit_with_fallback(self, curve_type: str, x_data: np.ndarray, y_data: np.ndarray) -> Dict:
        """å¸¦é™çº§ç­–ç•¥çš„æ›²çº¿æ‹Ÿåˆ"""
        
        # æ•°æ®è´¨é‡é¢„æ£€
        data_quality = self._assess_data_quality(x_data, y_data)
        
        # é€‰æ‹©é™çº§é“¾
        category = "pump_group_curves" if "group" in curve_type else "basic_pump_curves"
        methods = self.fallback_chain[category]
        
        # ä¾æ¬¡å°è¯•æ‹Ÿåˆæ–¹æ³•
        for i, method in enumerate(methods):
            try:
                result = await self._fit_with_method(method, x_data, y_data)
                quality = self._evaluate_quality(result, x_data, y_data)
                
                if self._is_quality_acceptable(quality, method):
                    return {
                        "model": result,
                        "method": method,
                        "quality": quality,
                        "fallback_level": i
                    }
            except Exception as e:
                continue
        
        # ä½¿ç”¨é»˜è®¤æ›²çº¿
        return {
            "model": self._get_default_curve(curve_type),
            "method": FittingMethod.DEFAULT_CURVE,
            "fallback_level": 3
        }
    
    def _assess_data_quality(self, x_data: np.ndarray, y_data: np.ndarray) -> float:
        """è¯„ä¼°æ•°æ®è´¨é‡"""
        quality = 1.0
        
        # æ ·æœ¬æ•°é‡
        if len(x_data) < 50:
            quality *= 0.7
        
        # æ•°æ®åˆ†å¸ƒ
        if np.std(x_data) == 0:
            quality *= 0.1
            
        # å¼‚å¸¸å€¼æ¯”ä¾‹
        q75, q25 = np.percentile(y_data, [75, 25])
        iqr = q75 - q25
        outliers = np.sum((y_data < (q25 - 1.5 * iqr)) | (y_data > (q75 + 1.5 * iqr)))
        outlier_ratio = outliers / len(y_data)
        quality *= (1 - outlier_ratio)
        
        return max(0.0, min(1.0, quality))

    def _is_quality_acceptable(self, quality_metrics: Dict, method: FittingMethod) -> bool:
        """åˆ¤æ–­è´¨é‡æ˜¯å¦å¯æ¥å—"""
        
        method_requirements = {
            FittingMethod.NEURAL_NETWORK: self.quality_thresholds["excellent"],
            FittingMethod.RANDOM_FOREST: self.quality_thresholds["good"],
            FittingMethod.GRADIENT_BOOSTING: self.quality_thresholds["good"],
            FittingMethod.POLYNOMIAL: self.quality_thresholds["acceptable"],
            FittingMethod.SPLINE: self.quality_thresholds["acceptable"],
            FittingMethod.LINEAR: self.quality_thresholds["poor"],
            FittingMethod.DEFAULT_CURVE: {"r2": 0.0, "rmse_threshold": float('inf')}
        }
        
        requirements = method_requirements.get(method, self.quality_thresholds["poor"])
        
        return (quality_metrics.get('r2', 0) >= requirements['r2'] and 
                quality_metrics.get('rmse', float('inf')) <= requirements['rmse_threshold'])

    async def _fit_with_method(self, method: FittingMethod, x_data: np.ndarray, y_data: np.ndarray):
        """ä½¿ç”¨æŒ‡å®šæ–¹æ³•æ‹Ÿåˆ"""
        
        if method == FittingMethod.NEURAL_NETWORK:
            return await self._neural_network_fitting(x_data, y_data)
        elif method == FittingMethod.RANDOM_FOREST:
            return await self._random_forest_fitting(x_data, y_data)
        elif method == FittingMethod.GRADIENT_BOOSTING:
            return await self._gradient_boosting_fitting(x_data, y_data)
        elif method == FittingMethod.POLYNOMIAL:
            return await self._polynomial_fitting(x_data, y_data)
        elif method == FittingMethod.SPLINE:
            return await self._spline_fitting(x_data, y_data)
        elif method == FittingMethod.LINEAR:
            return await self._linear_fitting(x_data, y_data)
        else:
            return self._get_default_curve(curve_type)

    def _get_default_curve(self, curve_type: str):
        """è·å–é»˜è®¤ç†è®ºæ›²çº¿"""
        
        default_curves = {
            "HQ": lambda Q: 45 - 0.0001 * Q**2,  # å…¸å‹æ‰¬ç¨‹æ›²çº¿
            "EtaQ": lambda Q: 0.8 * (1 - ((Q - 100) / 100)**2),  # å…¸å‹æ•ˆç‡æ›²çº¿  
            "PQ": lambda Q: 0.0001 * Q**3 + 0.01 * Q**2 + 0.5 * Q + 5,  # å…¸å‹åŠŸç‡æ›²çº¿
            "pump_group_power": lambda Q_total: sum([self._single_pump_power(Q_total/n) for n in range(1, 5)]),
            "pump_group_efficiency": lambda load_rate: 0.85 * (1 - (load_rate - 0.8)**2) if 0.5 <= load_rate <= 1.2 else 0.5
        }
        
        return default_curves.get(curve_type, lambda x: 0)
```

### æ™ºèƒ½æ•°æ®ç­›é€‰

**å¤šå±‚æ¬¡é™çº§ç­–ç•¥**ï¼š
1. **ç¥ç»ç½‘ç»œæ‹Ÿåˆ** â†’ 2. **éšæœºæ£®æ—** â†’ 3. **å¤šé¡¹å¼æ‹Ÿåˆ** â†’ 4. **çº¿æ€§æ‹Ÿåˆ** â†’ 5. **é»˜è®¤æ›²çº¿**

**æ™ºèƒ½æ•°æ®ç­›é€‰**ï¼š
- æ’é™¤FFILLè¡¥é½æ•°æ®ï¼ˆè¿ç»­ç›¸åŒå€¼æ£€æµ‹ï¼‰
- æ’é™¤MEANè¡¥é½æ•°æ®ï¼ˆç»Ÿè®¡å¼‚å¸¸æ£€æµ‹ï¼‰
- æ’é™¤REGè¡¥é½æ•°æ®ï¼ˆè¿‡åº¦å¹³æ»‘æ£€æµ‹ï¼‰
- ä»…ä½¿ç”¨åŸå§‹é«˜è´¨é‡æ•°æ®è¿›è¡Œæ‹Ÿåˆ

**è´¨é‡è¯„ä¼°æ ‡å‡†**ï¼š
- RÂ² > 0.90 (ä¼˜ç§€) > 0.80 (è‰¯å¥½) > 0.65 (å¯æ¥å—) > 0.40 (å·®)
- ç‰©ç†çº¦æŸéªŒè¯ï¼šæ•ˆç‡0-100%ï¼Œåè°ƒç³»æ•°0.5-1.5ï¼ŒåŠŸç‡>0ç­‰
- æ ·æœ¬æ•°é‡è¦æ±‚ï¼šæœ€å°‘20ä¸ªæœ‰æ•ˆæ•°æ®ç‚¹

### æ•°æ®ç­›é€‰å®ç°

```python
class IntelligentDataSelector:
    """æ™ºèƒ½æ•°æ®ç­›é€‰å™¨"""
    
    def __init__(self):
        self.quality_filters = {
            'remove_filled_data': self._remove_filled_data,
            'remove_outliers': self._remove_outliers,
            'ensure_steady_state': self._ensure_steady_state,
            'validate_physical_range': self._validate_physical_range
        }
    
    async def select_high_quality_data(self, station_id: str, device_id: str, 
                                     curve_type: str, days: int = 30) -> CurveData:
        """é€‰æ‹©é«˜è´¨é‡æ•°æ®ç”¨äºæ›²çº¿æ‹Ÿåˆ"""
        
        # 1. è·å–åŸå§‹æ•°æ®
        raw_data = await self._fetch_raw_data(station_id, device_id, days)
        
        # 2. åº”ç”¨è´¨é‡è¿‡æ»¤å™¨
        filtered_data = raw_data
        for filter_name, filter_func in self.quality_filters.items():
            filtered_data = await filter_func(filtered_data, curve_type)
            self.logger.info(f"è¿‡æ»¤å™¨ {filter_name} ä¿ç•™æ•°æ®: {len(filtered_data)}")
        
        # 3. éªŒè¯æœ€ç»ˆæ•°æ®è´¨é‡
        if len(filtered_data) < 20:
            self.logger.warning(f"æ•°æ®é‡ä¸è¶³ï¼Œä»…{len(filtered_data)}ä¸ªæ ·æœ¬")
            return self._get_extended_data(station_id, device_id, curve_type, days=60)
        
        return CurveData(
            x_data=filtered_data['x_values'],
            y_data=filtered_data['y_values'],
            timestamps=filtered_data['timestamps'],
            quality_score=self._calculate_data_quality_score(filtered_data)
        )
    
    async def _remove_filled_data(self, data: Dict, curve_type: str) -> Dict:
        """ç§»é™¤è¡¥é½æ•°æ®"""
        
        # æ£€æµ‹FFILLè¡¥é½ï¼šè¿ç»­ç›¸åŒå€¼
        ffill_mask = self._detect_ffill_pattern(data['y_values'])
        
        # æ£€æµ‹MEANè¡¥é½ï¼šç»Ÿè®¡å¼‚å¸¸
        mean_mask = self._detect_mean_pattern(data['y_values'])
        
        # æ£€æµ‹REGè¡¥é½ï¼šè¿‡åº¦å¹³æ»‘
        reg_mask = self._detect_regression_pattern(data['y_values'])
        
        # åˆå¹¶æ©ç ï¼Œä¿ç•™åŸå§‹æ•°æ®
        valid_mask = ~(ffill_mask | mean_mask | reg_mask)
        
        return {
            'x_values': data['x_values'][valid_mask],
            'y_values': data['y_values'][valid_mask], 
            'timestamps': data['timestamps'][valid_mask]
        }
    
    def _detect_ffill_pattern(self, y_values: np.ndarray) -> np.ndarray:
        """æ£€æµ‹å‰å‘å¡«å……æ¨¡å¼"""
        # æ£€æµ‹è¿ç»­ç›¸åŒå€¼ï¼ˆFFILLç‰¹å¾ï¼‰
        consecutive_same = np.zeros(len(y_values), dtype=bool)
        
        for i in range(1, len(y_values)):
            if abs(y_values[i] - y_values[i-1]) < 1e-6:  # å‡ ä¹ç›¸åŒ
                consecutive_same[i] = True
                # å‘å‰ä¼ æ’­ï¼Œæ ‡è®°è¿ç»­æ®µ
                j = i - 1
                while j >= 0 and abs(y_values[j] - y_values[i]) < 1e-6:
                    consecutive_same[j] = True
                    j -= 1
        
        return consecutive_same
    
    def _detect_mean_pattern(self, y_values: np.ndarray) -> np.ndarray:
        """æ£€æµ‹å‡å€¼å¡«å……æ¨¡å¼"""
        # æ£€æµ‹æ˜¯å¦ä¸ºå±€éƒ¨å‡å€¼ï¼ˆMEANç‰¹å¾ï¼‰
        mean_filled = np.zeros(len(y_values), dtype=bool)
        
        window = 5  # æ£€æŸ¥çª—å£
        for i in range(window, len(y_values) - window):
            local_window = y_values[i-window:i+window+1]
            local_mean = np.mean(local_window[local_window != y_values[i]])
            
            # å¦‚æœå€¼æ¥è¿‘å±€éƒ¨å‡å€¼ï¼Œå¯èƒ½æ˜¯MEANå¡«å……
            if len(local_window) > 1 and abs(y_values[i] - local_mean) < 0.01 * local_mean:
                mean_filled[i] = True
        
        return mean_filled
    
    def _detect_regression_pattern(self, y_values: np.ndarray) -> np.ndarray:
        """æ£€æµ‹å›å½’å¡«å……æ¨¡å¼"""
        # æ£€æµ‹è¿‡åº¦å¹³æ»‘ï¼ˆREGç‰¹å¾ï¼‰
        reg_filled = np.zeros(len(y_values), dtype=bool)
        
        # è®¡ç®—äºŒé˜¶å·®åˆ†ï¼Œæ£€æµ‹å¼‚å¸¸å¹³æ»‘
        if len(y_values) > 2:
            second_diff = np.diff(y_values, n=2)
            smooth_threshold = np.std(second_diff) * 0.1
            
            for i in range(1, len(y_values) - 1):
                if abs(second_diff[i-1]) < smooth_threshold:
                    reg_filled[i] = True
        
        return reg_filled
```

### æ›²çº¿è´¨é‡éªŒè¯

```python
class CurveQualityValidator:
    """æ›²çº¿è´¨é‡éªŒè¯å™¨"""
    
    def __init__(self):
        self.validation_criteria = {
            'r2_threshold': {'excellent': 0.90, 'good': 0.80, 'acceptable': 0.65},
            'rmse_threshold': {'excellent': 0.05, 'good': 0.10, 'acceptable': 0.20},
            'physical_constraints': True,
            'cross_validation': True
        }
    
    async def comprehensive_validation(self, fitted_curve: FittingResult, 
                                    validation_data: List[DataPoint]) -> ValidationReport:
        """ç»¼åˆéªŒè¯æ‹Ÿåˆæ›²çº¿"""
        
        # 1. ç»Ÿè®¡æŒ‡æ ‡éªŒè¯
        r2_score = self._calculate_r2(fitted_curve, validation_data)
        rmse = self._calculate_rmse(fitted_curve, validation_data)
        mae = self._calculate_mae(fitted_curve, validation_data)
        
        # 2. ç‰©ç†æ„ä¹‰éªŒè¯
        physics_check = self._validate_physics_constraints(fitted_curve)
        
        # 3. å®é™…è¿è¡ŒéªŒè¯ï¼ˆä½¿ç”¨æœ€è¿‘å†å²æ•°æ®ï¼‰
        recent_data = await self._get_recent_operation_data(device_id, days=7)
        operational_accuracy = self._validate_against_operation(fitted_curve, recent_data)
        
        # 4. äº¤å‰éªŒè¯
        cv_scores = await self._cross_validation(fitting_data, k=5)
        
        return ValidationReport(
            r2=r2_score,
            rmse=rmse, 
            mae=mae,
            physics_valid=physics_check.is_valid,
            operational_accuracy=operational_accuracy,
            cv_mean=cv_scores.mean(),
            quality_grade=self._assign_quality_grade(r2_score, rmse),
            recommendation=self._generate_recommendation(r2_score, rmse, physics_check)
        )
    
    def _assign_quality_grade(self, r2: float, rmse: float) -> str:
        """åˆ†é…è´¨é‡ç­‰çº§"""
        if r2 >= 0.90 and rmse <= 0.05:
            return 'A+çº§ - é«˜ç²¾åº¦å·¥ç¨‹çº§'
        elif r2 >= 0.80 and rmse <= 0.10:
            return 'Açº§ - å·¥ç¨‹åˆæ ¼'
        elif r2 >= 0.65 and rmse <= 0.20:
            return 'Bçº§ - åŸºæœ¬å¯ç”¨'
        elif r2 >= 0.40 and rmse <= 0.35:
            return 'Cçº§ - éœ€è¦æ”¹è¿›'
        else:
            return 'Dçº§ - ä¸å»ºè®®ä½¿ç”¨'
```

è¿™ä¸ªæ³µç»„åè°ƒç‰¹æ€§æ›²çº¿ä½“ç³»å®šä¹‰æ¨¡å—æä¾›äº†ï¼š

1. **å®Œæ•´çš„Fç±»æ³µç»„åè°ƒæ›²çº¿** - 20ç§æ–°å¢çš„æ³µç»„ç‰¹æ€§æ›²çº¿å®šä¹‰ï¼ˆ64-83ï¼‰
2. **å¤šå±‚æ¬¡é™çº§ç­–ç•¥** - ç¡®ä¿æ‹Ÿåˆçš„é²æ£’æ€§å’Œå¯é æ€§
3. **æ™ºèƒ½æ•°æ®ç­›é€‰** - æ’é™¤è¡¥é½æ•°æ®ï¼Œä½¿ç”¨é«˜è´¨é‡åŸå§‹æ•°æ®
4. **è´¨é‡éªŒè¯ä½“ç³»** - å¤šç»´åº¦éªŒè¯æ‹Ÿåˆç»“æœçš„å·¥ç¨‹å¯ç”¨æ€§

é€šè¿‡è¿™äº›å®Œæ•´çš„æ›²çº¿ä½“ç³»å’Œè´¨é‡ä¿è¯æœºåˆ¶ï¼Œç³»ç»Ÿèƒ½å¤Ÿå®ç°60%ä»¥ä¸Šçš„ç²¾åº¦æå‡ç›®æ ‡ã€‚