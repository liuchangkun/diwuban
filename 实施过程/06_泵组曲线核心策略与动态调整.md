# æ³µç»„ç‰¹æ€§æ›²çº¿æ‹Ÿåˆ - æ ¸å¿ƒç­–ç•¥ä¸åŠ¨æ€è°ƒæ•´æœºåˆ¶

## ğŸ“‹ æ ¸å¿ƒç­–ç•¥é€‰æ‹©ä¸åŠ¨æ€è°ƒæ•´æœºåˆ¶

### 1. ç¼ºå¤±æ•°æ®è¡¥é½ç­–ç•¥æ™ºèƒ½é€‰æ‹©

#### ğŸ¯ è¡¥é½ç­–ç•¥ä¼˜å…ˆçº§
```
FFILL (å‰å‘å¡«å……) â†’ MEAN (å‡å€¼å¡«å……) â†’ REG (å›å½’è¡¥é½) â†’ CURVE_ENHANCED (æ›²çº¿å¢å¼º)
```

#### ğŸ“Š æ™ºèƒ½é€‰æ‹©å†³ç­–æ ‘
```python
class DataCompletionStrategySelector:
    def select_optimal_strategy(self, missing_gap_hours: int, data_quality: float, 
                              context_availability: bool, curve_availability: bool) -> str:
        """
        æ™ºèƒ½é€‰æ‹©è¡¥é½ç­–ç•¥
        
        å‚æ•°:
            missing_gap_hours: ç¼ºå¤±æ—¶é—´è·¨åº¦ï¼ˆå°æ—¶ï¼‰
            data_quality: æ•°æ®è´¨é‡è¯„åˆ† (0-1)
            context_availability: æ˜¯å¦æœ‰ä¸Šä¸‹æ–‡æ•°æ®
            curve_availability: æ˜¯å¦æœ‰å¯ç”¨ç‰¹æ€§æ›²çº¿
        """
        
        # 1. çŸ­ç¼ºå£ï¼ˆ<2å°æ—¶ï¼‰ï¼šFFILLä¼˜å…ˆ
        if missing_gap_hours <= 2 and context_availability:
            return "FFILL"
        
        # 2. ä¸­ç­‰ç¼ºå£ï¼ˆ2-12å°æ—¶ï¼‰ï¼šMEANç­–ç•¥
        elif missing_gap_hours <= 12 and data_quality > 0.7:
            return "MEAN"
        
        # 3. é•¿æœŸç¼ºå£ï¼ˆ>12å°æ—¶ï¼‰ï¼šREGå›å½’
        elif missing_gap_hours > 12 and data_quality > 0.5:
            return "REG"
        
        # 4. é«˜çº§ç­–ç•¥ï¼šCURVE_ENHANCEDï¼ˆå½“æœ‰æ‹Ÿåˆæ›²çº¿æ—¶ï¼‰
        elif curve_availability and data_quality > 0.6:
            return "CURVE_ENHANCED"
        
        # 5. å…œåº•ç­–ç•¥ï¼šé™çº§åˆ°MEAN
        else:
            return "MEAN"
```

### 2. ç‰¹æ€§æ›²çº¿æ‹Ÿåˆæ–¹æ³•é€‰æ‹©

#### ğŸ¯ æ‹Ÿåˆç®—æ³•ä¼˜å…ˆçº§
```
ç¥ç»ç½‘ç»œ â†’ éšæœºæ£®æ— â†’ é«˜æ–¯è¿‡ç¨‹ â†’ å¤šé¡¹å¼ â†’ æ ·æ¡ â†’ çº¿æ€§ â†’ é»˜è®¤æ›²çº¿
```

#### ğŸ“Š å¤šç®—æ³•å¹¶è¡Œä¼˜åŒ–ç­–ç•¥
```python
class MultiAlgorithmCurveFitter:
    def __init__(self):
        self.methods_priority = [
            ("neural_network", {"min_samples": 200, "r2_threshold": 0.90}),
            ("random_forest", {"min_samples": 100, "r2_threshold": 0.85}),
            ("gaussian_process", {"min_samples": 50, "r2_threshold": 0.80}),
            ("polynomial", {"min_samples": 30, "r2_threshold": 0.70}),
            ("spline", {"min_samples": 20, "r2_threshold": 0.60}),
            ("linear", {"min_samples": 10, "r2_threshold": 0.40})
        ]
    
    async def fit_all_algorithms_parallel(self, data: CurveData) -> Dict[str, FittingResult]:
        """å¹¶è¡Œæ‰§è¡Œæ‰€æœ‰é€‚ç”¨ç®—æ³•"""
        tasks = []
        for method, criteria in self.methods_priority:
            if len(data) >= criteria["min_samples"]:
                task = self._fit_single_method(method, data)
                tasks.append((method, task))
        
        results = await asyncio.gather(*[task for _, task in tasks])
        return dict(zip([method for method, _ in tasks], results))
```

### 3. åŠ¨æ€ç²¾åº¦è°ƒæ•´æœºåˆ¶

#### ğŸ”„ å®é™…è¿è¡Œæ•°æ®è¯Šæ–­ä¸é‡æ‹Ÿåˆ
```python
class DynamicFittingAdjustment:
    async def diagnose_and_readjust(self, fitted_curve: FittingResult, 
                                  station_id: str, curve_type: str) -> FittingResult:
        """
        é€šè¿‡å®é™…è¿è¡Œæ•°æ®è¯Šæ–­ç²¾åº¦ï¼Œå¦‚æœè¿‡ä½åˆ™æ›´æ”¹æ‹Ÿåˆæ–¹æ³•å†æ¥ä¸€æ¬¡
        """
        
        # 1. è·å–æœ€è¿‘7å¤©å®é™…è¿è¡Œæ•°æ®
        recent_data = await self._get_recent_operation_data(station_id, days=7)
        
        if not recent_data:
            return fitted_curve  # æ— æ•°æ®æ—¶ä¿æŒåŸç»“æœ
        
        # 2. è®¡ç®—å®é™…è¿è¡Œç²¾åº¦
        operational_accuracy = await self._calculate_operational_accuracy(
            fitted_curve, recent_data
        )
        
        self.logger.info(
            "curve.accuracy.diagnosis",
            station_id=station_id,
            curve_type=curve_type,
            operational_accuracy=operational_accuracy,
            threshold=0.7
        )
        
        # 3. ç²¾åº¦è¯Šæ–­ï¼šå¦‚æœä½äº70%é˜ˆå€¼ï¼Œå¯åŠ¨é‡æ‹Ÿåˆ
        if operational_accuracy < 0.7:
            self.logger.warning(
                f"æ›²çº¿ç²¾åº¦è¿‡ä½({operational_accuracy:.2%})ï¼Œå¯åŠ¨åŠ¨æ€è°ƒæ•´é‡æ‹Ÿåˆ"
            )
            
            # 4. å°è¯•ä¸åŒæ‹Ÿåˆç­–ç•¥
            adjusted_curve = await self._try_alternative_methods(station_id, curve_type)
            
            # 5. éªŒè¯æ–°æ‹Ÿåˆç»“æœ
            new_accuracy = await self._calculate_operational_accuracy(
                adjusted_curve, recent_data
            )
            
            # 6. é€‰æ‹©æœ€ä¼˜ç»“æœ
            if new_accuracy > operational_accuracy:
                self.logger.info(
                    f"é‡æ‹ŸåˆæˆåŠŸï¼Œç²¾åº¦æå‡: {operational_accuracy:.2%} â†’ {new_accuracy:.2%}"
                )
                return adjusted_curve
            else:
                self.logger.warning(
                    f"é‡æ‹Ÿåˆæœªæ”¹å–„ï¼Œä¿æŒåŸç»“æœ: {operational_accuracy:.2%}"
                )
        
        return fitted_curve
    
    async def _try_alternative_methods(self, station_id: str, curve_type: str) -> FittingResult:
        """å°è¯•æ›¿ä»£æ‹Ÿåˆæ–¹æ³•"""
        
        alternative_strategies = [
            "ensemble_learning",      # é›†æˆå­¦ä¹ èåˆ
            "parameter_optimization", # å‚æ•°ä¼˜åŒ–é‡è¯•
            "segmented_fitting",      # åˆ†æ®µæ‹Ÿåˆ
            "robust_regression",      # é²æ£’å›å½’
            "hybrid_method"           # æ··åˆæ–¹æ³•
        ]
        
        best_result = None
        best_score = 0
        
        for strategy in alternative_strategies:
            try:
                result = await self._apply_strategy(strategy, station_id, curve_type)
                score = await self._evaluate_strategy_score(result)
                
                if score > best_score:
                    best_score = score
                    best_result = result
                    
            except Exception as e:
                self.logger.error(f"ç­–ç•¥ {strategy} å¤±è´¥: {e}")
                continue
        
        return best_result or self._get_default_curve(curve_type)
```

### 4. å®æ—¶ç›‘æ§ä¸åŠ¨æ€è°ƒæ•´

#### ğŸ”„ å®æ—¶ç›‘æ§ä¸è°ƒæ•´
```python
class RealTimeOptimizationMonitor:
    def __init__(self):
        self.performance_thresholds = {
            'accuracy_threshold': 0.70,  # 70%ç²¾åº¦é˜ˆå€¼
            'degradation_threshold': 0.05,  # 5%æ€§èƒ½ä¸‹é™é˜ˆå€¼
            'monitoring_window': 7  # 7å¤©ç›‘æ§çª—å£
        }
    
    async def continuous_monitoring(self, station_id: str) -> None:
        """æŒç»­ç›‘æ§å’Œä¼˜åŒ–"""
        
        while True:
            # 1. å®šæœŸè¯„ä¼°æ›²çº¿æ€§èƒ½
            performance = await self._evaluate_curve_performance(station_id)
            
            # 2. æ£€æµ‹æ€§èƒ½ä¸‹é™
            if performance['accuracy'] < self.performance_thresholds['accuracy_threshold']:
                # 3. è§¦å‘åŠ¨æ€é‡æ‹Ÿåˆ
                await self._trigger_dynamic_refitting(station_id, performance)
            
            # 4. ç­‰å¾…ä¸‹ä¸€ä¸ªç›‘æ§å‘¨æœŸ
            await asyncio.sleep(3600)  # 1å°æ—¶æ£€æŸ¥ä¸€æ¬¡
    
    async def _trigger_dynamic_refitting(self, station_id: str, performance: Dict) -> None:
        """è§¦å‘åŠ¨æ€é‡æ‹Ÿåˆ"""
        self.logger.warning(
            "curve.performance.degradation.detected",
            station_id=station_id,
            current_accuracy=performance['accuracy'],
            threshold=self.performance_thresholds['accuracy_threshold']
        )
        
        # è·å–ç›¸å…³æ›²çº¿
        affected_curves = await self._identify_affected_curves(station_id, performance)
        
        # æ‰¹é‡é‡æ‹Ÿåˆ
        refitting_tasks = []
        for curve_type in affected_curves:
            task = self._refit_single_curve(station_id, curve_type)
            refitting_tasks.append(task)
        
        # å¹¶è¡Œæ‰§è¡Œé‡æ‹Ÿåˆ
        refitting_results = await asyncio.gather(*refitting_tasks)
        
        # æ›´æ–°æ›²çº¿æ¨¡å‹
        await self._update_curve_models(station_id, refitting_results)
        
        self.logger.info(
            "curve.dynamic.refitting.completed",
            station_id=station_id,
            refitted_curves=len(refitting_results),
            new_accuracy=await self._calculate_updated_accuracy(station_id)
        )
```

### 5. è´¨é‡æ§åˆ¶ä¸éªŒè¯

#### ğŸ“Š è´¨é‡é˜ˆå€¼é™çº§æœºåˆ¶
```python
class QualityThresholdManager:
    quality_levels = {
        'excellent': {'r2': 0.90, 'rmse_max': 0.05, 'confidence': 0.95},
        'good': {'r2': 0.80, 'rmse_max': 0.10, 'confidence': 0.85},
        'acceptable': {'r2': 0.65, 'rmse_max': 0.20, 'confidence': 0.70},
        'poor': {'r2': 0.40, 'rmse_max': 0.35, 'confidence': 0.50}
    }
    
    def ensure_minimum_quality(self, fitting_result: FittingResult) -> bool:
        """ç¡®ä¿æœ€ä½è´¨é‡æ ‡å‡†"""
        return fitting_result.r2_score >= self.quality_levels['poor']['r2']
    
    def classify_quality_level(self, fitting_result: FittingResult) -> str:
        """åˆ†ç±»è´¨é‡ç­‰çº§"""
        r2 = fitting_result.r2_score
        rmse = fitting_result.rmse
        
        for level, criteria in self.quality_levels.items():
            if r2 >= criteria['r2'] and rmse <= criteria['rmse_max']:
                return level
        
        return 'unacceptable'  # ä½äºæœ€ä½æ ‡å‡†
```

### 6. å…³é”®æŒ‡æ ‡ç›‘æ§

#### ğŸ“Š å…³é”®æŒ‡æ ‡ç›‘æ§
```python
class PerformanceMetrics:
    key_metrics = {
        'completion_success_rate': 0.95,  # è¡¥é½æˆåŠŸç‡
        'fitting_accuracy': 0.85,         # æ‹Ÿåˆç²¾åº¦
        'dynamic_adjustment_frequency': 0.1, # åŠ¨æ€è°ƒæ•´é¢‘ç‡
        'system_response_time': 30,       # ç³»ç»Ÿå“åº”æ—¶é—´(ç§’)
        'overall_improvement': 0.6        # æ•´ä½“æ”¹å–„å¹…åº¦
    }
    
    async def collect_performance_metrics(self, station_id: str) -> Dict:
        """æ”¶é›†æ€§èƒ½æŒ‡æ ‡"""
        return {
            'completion_success_rate': await self._calculate_completion_success_rate(station_id),
            'average_fitting_accuracy': await self._calculate_average_fitting_accuracy(station_id),
            'dynamic_adjustment_frequency': await self._calculate_adjustment_frequency(station_id),
            'average_response_time': await self._calculate_response_time(station_id),
            'overall_improvement': await self._calculate_overall_improvement(station_id)
        }
```

è¿™ä¸ªæ ¸å¿ƒç­–ç•¥ä¸åŠ¨æ€è°ƒæ•´æœºåˆ¶æ¨¡å—æä¾›äº†ï¼š

1. **æ™ºèƒ½ç­–ç•¥é€‰æ‹©** - æ ¹æ®æ•°æ®ç‰¹å¾è‡ªåŠ¨é€‰æ‹©æœ€ä¼˜è¡¥é½å’Œæ‹Ÿåˆç­–ç•¥
2. **å¹¶è¡Œç®—æ³•ä¼˜åŒ–** - åŒæ—¶è¿è¡Œå¤šç§ç®—æ³•å¹¶é€‰æ‹©æœ€ä¼˜ç»“æœ
3. **åŠ¨æ€ç²¾åº¦è°ƒæ•´** - åŸºäºå®é™…è¿è¡Œæ•°æ®è¯Šæ–­å’Œé‡æ‹Ÿåˆ
4. **å®æ—¶ç›‘æ§æœºåˆ¶** - æŒç»­ç›‘æ§æ€§èƒ½å¹¶è§¦å‘è‡ªåŠ¨ä¼˜åŒ–
5. **è´¨é‡æ§åˆ¶ä½“ç³»** - ç¡®ä¿æ‹Ÿåˆç»“æœè¾¾åˆ°å·¥ç¨‹åº”ç”¨æ ‡å‡†

é€šè¿‡è¿™äº›æœºåˆ¶ï¼Œç³»ç»Ÿèƒ½å¤Ÿè‡ªé€‚åº”åœ°ç»´æŒå’Œæ”¹è¿›æ‹Ÿåˆè´¨é‡ï¼Œå®ç°çœŸæ­£çš„å·¥ç¨‹å¯ç”¨æ€§ã€‚