# 水泵性能分析与优化系统技术规范

> 本规范定义了水泵性能分析与优化系统的技术架构、数据处理流程、曲线拟合算法、优化方法以及监控与评估体系。

## 🔧 如何使用本规范推动开发/测试/优化
- 开发入口：按“系统架构文档”中的目录实现模块 → [系统架构](system_architecture.md#21-项目目录结构)
- 数据规范：数据清洗/标准化细则 → [数据处理规范](data_processing_specifications.md)
- 拟合与优化：本文件第4章与第5章的算法实现指引 + [优化算法规范](optimization_algorithms_specifications.md)
- 质量门槛与测试：整体测试框架与门槛 → [测试与质量保证规范](testing_quality_assurance_specifications.md)
- 工程参数公式：水泵专用工程公式与边界 → [水泵工程参数计算规范](pump_engineering_parameter_calculation_specifications.md)
- 实时链路：实时采集/监控/告警 → [实时处理规范](real_time_processing_specifications.md)

## 1. 系统概述

### 1.1 项目背景
- **目标**：构建智能化水泵性能分析与优化系统
- **范围**：涵盖性能曲线拟合、实时监控、效率优化、预测性维护
- **数据源**：CSV文件格式的运行数据
- **技术栈**：Python 3.13.6 + pandas + numpy + scikit-learn

### 1.2 核心功能
- 水泵性能曲线自动拟合与建模
- 实时运行状态监控与异常检测
- 多目标优化算法与参数调优
- 预测性维护与故障诊断
- 数据可视化与报告生成

## 2. 系统架构

### 2.1 模块架构
```
app/
├── core/                    # 核心模块
│   ├── data_loader.py      # 数据加载与预处理
│   ├── curve_fitting.py    # 曲线拟合算法
│   ├── optimizer.py        # 优化算法
│   └── monitor.py          # 监控模块
├── models/                 # 数据模型
├── utils/                  # 工具函数
└── config/                 # 配置管理
```

### 2.2 数据流架构
1. **数据输入**：CSV文件加载 → 数据清洗 → 格式标准化
2. **曲线拟合**：特性曲线建模 → 参数估计 → 模型验证
3. **实时监控**：数据采集 → 状态分析 → 异常告警
4. **优化计算**：目标设定 → 算法执行 → 结果输出

## 3. 数据处理规范

### 3.1 曲线类型定义

#### 3.1.1 基础性能曲线
- **扬程特性曲线**：H = f(Q) 关系建模
- **效率特性曲线**：η = f(Q) 关系建模
- **功率特性曲线**：P = f(Q) 关系建模

#### 3.1.2 振动特性曲线
- **振动幅值曲线**：振动强度随转速/负载变化
- **频域分析曲线**：振动频谱特征分析

#### 3.1.3 变频泵特性曲线
- **变频扬程曲线**：不同频率下的H-Q特性
- **变频效率曲线**：频率对效率的影响规律

#### 3.1.4 软启泵特性曲线
- **启动特性曲线**：启动过程参数变化
- **过渡特性曲线**：软启动到稳态的过渡过程

#### 3.1.5 泵组特性曲线
- **并联特性曲线**：多泵并联运行特性
- **串联特性曲线**：多泵串联运行特性

#### 3.1.6 系统特性曲线
- **阻力特性曲线**：系统阻力与流量关系

### 3.2 数据预处理

#### 3.2.1 数据清洗
- 异常值检测与处理
- 缺失值插补策略
- 数据平滑与滤波

#### 3.2.2 数据标准化
- 量纲统一处理
- 数值范围归一化
- 时间序列对齐

## 4. 曲线拟合算法

### 4.1 物理拟合方法

#### 4.1.1 欧拉方程拟合法
基于水泵叶轮欧拉方程的物理拟合方法，适用于离心泵理论扬程计算和叶轮设计参数反求。

**理论基础：**
```
H_th = (u₂c₂ᵤ - u₁c₁ᵤ) / g
```

**拟合模型：**
```
H = A × u₂² / g - B × Q²
```

详细实现参见：[水泵物理特性规范](pump_physical_characteristics_specifications.md)

#### 4.1.2 相似定律拟合法
基于水泵相似定律的拟合方法，适用于变频泵特性预测和不同转速工况分析。

**相似定律公式：**
```
Q₁/Q₂ = (n₁/n₂) × (D₁/D₂)³
H₁/H₂ = (n₁/n₂)² × (D₁/D₂)²
P₁/P₂ = (ρ₁/ρ₂) × (n₁/n₂)³ × (D₁/D₂)⁵
```

#### 4.1.3 比转速拟合法
基于比转速理论的拟合方法，适用于泵型选择优化和效率预测。

**比转速公式：**
```
ns = n × √Q / H^(3/4)
```

**泵型分类：**
- 离心泵：ns = 30-150
- 混流泵：ns = 150-500  
- 轴流泵：ns = 500-1500

### 4.2 传统数学拟合方法

#### 4.2.1 多项式拟合
```python
import numpy as np
import logging
from typing import Dict, Optional, List, Any

# 配置日志
logger = logging.getLogger(__name__)
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

class PolynomialFitter:
    """多项式曲线拟合器
    
    用于水泵特性曲线的多项式拟合，适用于流量-扬程、流量-功率等关系建模。
    常用于二次、三次多项式拟合，具有计算简单、收敛稳定的优点。
    """
    
    def __init__(self, degree: int = 3) -> None:
        """
        初始化多项式拟合器
        
        Args:
            degree: 多项式阶数，通常取2-4阶，过高容易过拟合
            
        Raises:
            ValueError: 当阶数小于1时抛出异常
        """
        if degree < 1:
            raise ValueError("多项式阶数必须大于等于1")
        self.degree = degree
        self.coefficients: Optional[np.ndarray] = None
        self.r_squared: Optional[float] = None

    def fit(self, x: np.ndarray, y: np.ndarray) -> np.ndarray:
        """
        执行多项式拟合
        
        Args:
            x: 自变量数据，如流量 (m³/h)
            y: 因变量数据，如扬程 (m) 或功率 (kW)
            
        Returns:
            拟合系数数组，从高次到低次排列
            
        Raises:
            ValueError: 当输入数据长度不匹配或包含无效值时抛出异常
        """
        if len(x) != len(y):
            raise ValueError("x和y数据长度必须相等")
        if len(x) <= self.degree:
            raise ValueError(f"数据点数量({len(x)})必须大于多项式阶数({self.degree})")
            
        # 检查并移除无效值
        valid_mask = np.isfinite(x) & np.isfinite(y)
        x_clean, y_clean = x[valid_mask], y[valid_mask]
        
        if len(x_clean) == 0:
            raise ValueError("没有有效的数据点")
        
        # 执行多项式拟合
        self.coefficients = np.polyfit(x_clean, y_clean, self.degree)
        
        # 计算决定系数 R²
        y_pred = np.polyval(self.coefficients, x_clean)
        ss_res = np.sum((y_clean - y_pred) ** 2)
        ss_tot = np.sum((y_clean - np.mean(y_clean)) ** 2)
        self.r_squared = 1 - (ss_res / ss_tot) if ss_tot != 0 else 0.0
        
        return self.coefficients
    
    def predict(self, x: np.ndarray) -> np.ndarray:
        """
        预测新数据点
        
        Args:
            x: 待预测的自变量
            
        Returns:
            预测结果
            
        Raises:
            RuntimeError: 当模型未训练时抛出异常
        """
        if self.coefficients is None:
            raise RuntimeError("模型尚未训练，请先调用fit方法")
        return np.polyval(self.coefficients, x)

# 最小可运行示例
if __name__ == "__main__":
    # 模拟水泵流量-扬程数据
    flow = np.array([10, 20, 30, 40, 50, 60])  # 流量 m³/h
    head = np.array([120, 115, 108, 98, 85, 70])  # 扬程 m
    
    # 创建拟合器并训练
    fitter = PolynomialFitter(degree=2)
    coeffs = fitter.fit(flow, head)
    
    logger.info(f"拟合系数: {coeffs}")
    logger.info(f"R²: {fitter.r_squared:.4f}")
    
    # 预测新流量点的扬程
    new_flow = np.array([25, 45])
    predicted_head = fitter.predict(new_flow)
    logger.info(f"流量 {new_flow} m³/h 对应扬程: {predicted_head} m")
```

#### 4.2.2 幂函数拟合
```python
import numpy as np
import logging
from typing import Dict, Optional

# 配置日志
logger = logging.getLogger(__name__)
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

class PowerFitter:
    """幂函数曲线拟合器
    
    用于水泵相似律和功率特性曲线拟合，形式为 y = a * x^b。
    特别适用于流量-功率关系(通常b≈3)和相似律转换(转速比例关系)。
    """
    
    def __init__(self) -> None:
        """初始化幂函数拟合器"""
        self.parameters: Optional[Dict[str, float]] = None
        self.r_squared: Optional[float] = None
    
    def fit(self, x: np.ndarray, y: np.ndarray) -> Dict[str, float]:
        """
        执行幂函数拟合 y = a * x^b
        
        Args:
            x: 自变量数据，如流量 (m³/h) 或转速 (rpm)
            y: 因变量数据，如功率 (kW) 或扬程 (m)
            
        Returns:
            拟合参数字典，包含 'a'(系数) 和 'b'(指数)
            
        Raises:
            ValueError: 当输入数据包含非正值或长度不匹配时抛出异常
        """
        if len(x) != len(y):
            raise ValueError("x和y数据长度必须相等")
        
        # 检查正值约束
        if np.any(x <= 0) or np.any(y <= 0):
            raise ValueError("幂函数拟合要求所有数据点均为正值")
        
        # 对数变换：ln(y) = ln(a) + b*ln(x)
        log_x = np.log(x)
        log_y = np.log(y)
        
        # 检查变换后的有效性
        valid_mask = np.isfinite(log_x) & np.isfinite(log_y)
        if not np.any(valid_mask):
            raise ValueError("对数变换后没有有效数据点")
        
        log_x_clean = log_x[valid_mask]
        log_y_clean = log_y[valid_mask]
        
        # 线性回归拟合
        coeffs = np.polyfit(log_x_clean, log_y_clean, 1)
        b = coeffs[0]  # 指数
        a = np.exp(coeffs[1])  # 系数
        
        # 计算决定系数 R²
        log_y_pred = coeffs[1] + b * log_x_clean
        ss_res = np.sum((log_y_clean - log_y_pred) ** 2)
        ss_tot = np.sum((log_y_clean - np.mean(log_y_clean)) ** 2)
        self.r_squared = 1 - (ss_res / ss_tot) if ss_tot != 0 else 0.0
        
        self.parameters = {"a": a, "b": b}
        return self.parameters
    
    def predict(self, x: np.ndarray) -> np.ndarray:
        """
        预测新数据点
        
        Args:
            x: 待预测的自变量
            
        Returns:
            预测结果
            
        Raises:
            RuntimeError: 当模型未训练时抛出异常
            ValueError: 当输入包含非正值时抛出异常
        """
        if self.parameters is None:
            raise RuntimeError("模型尚未训练，请先调用fit方法")
        
        if np.any(x <= 0):
            raise ValueError("预测输入必须为正值")
        
        a, b = self.parameters["a"], self.parameters["b"]
        return a * np.power(x, b)

# 最小可运行示例
if __name__ == "__main__":
    # 模拟水泵流量-功率数据（理论上功率与流量的三次方成正比）
    flow = np.array([10, 20, 30, 40, 50, 60])  # 流量 m³/h
    power = np.array([0.8, 6.4, 21.6, 51.2, 100, 172.8])  # 功率 kW
    
    # 创建拟合器并训练
    fitter = PowerFitter()
    params = fitter.fit(flow, power)
    
    logger.info(f"拟合参数: a={params['a']:.4f}, b={params['b']:.4f}")
    logger.info(f"R²: {fitter.r_squared:.4f}")
    
    # 预测新流量点的功率
    new_flow = np.array([25, 45])
    predicted_power = fitter.predict(new_flow)
    logger.info(f"流量 {new_flow} m³/h 对应功率: {predicted_power:.2f} kW")
    
    # 验证相似律：功率与流量三次方关系
    logger.info(f"实际指数 b={params['b']:.2f}，理论值应接近3.0")
```

#### 4.2.3 指数函数拟合
```python
import numpy as np
import logging
from typing import Dict, Optional

# 配置日志
logger = logging.getLogger(__name__)
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

class ExponentialFitter:
    """指数函数曲线拟合器
    
    用于拟合 y = a * exp(b*x) 形式的关系，适用于某些泵的老化退化曲线、
    泵房设备温升等近似指数关系的场景。
    """
    
    def __init__(self) -> None:
        """初始化指数拟合器"""
        self.parameters: Optional[Dict[str, float]] = None
        self.r_squared: Optional[float] = None
    
    def fit(self, x: np.ndarray, y: np.ndarray) -> Dict[str, float]:
        """
        执行指数函数拟合 y = a * exp(b*x)
        
        Args:
            x: 自变量数据
            y: 因变量数据，必须为正值
            
        Returns:
            拟合参数字典，包含 'a' 与 'b'
            
        Raises:
            ValueError: 当y包含非正值或长度不匹配时抛出异常
        """
        if len(x) != len(y):
            raise ValueError("x和y数据长度必须相等")
        if np.any(y <= 0):
            raise ValueError("指数拟合要求y为正值")
        
        # 对数变换：ln(y) = ln(a) + b*x
        log_y = np.log(y)
        
        # 检查有效性
        valid_mask = np.isfinite(x) & np.isfinite(log_y)
        if not np.any(valid_mask):
            raise ValueError("没有有效数据点")
        x_clean = x[valid_mask]
        log_y_clean = log_y[valid_mask]
        
        # 线性回归
        coeffs = np.polyfit(x_clean, log_y_clean, 1)
        b = coeffs[0]
        a = np.exp(coeffs[1])
        
        # 计算决定系数 R²
        log_y_pred = coeffs[1] + b * x_clean
        ss_res = np.sum((log_y_clean - log_y_pred) ** 2)
        ss_tot = np.sum((log_y_clean - np.mean(log_y_clean)) ** 2)
        self.r_squared = 1 - (ss_res / ss_tot) if ss_tot != 0 else 0.0
        
        self.parameters = {"a": a, "b": b}
        return self.parameters
    
    def predict(self, x: np.ndarray) -> np.ndarray:
        """
        预测新数据点
        
        Args:
            x: 待预测的自变量
            
        Returns:
            预测结果
            
        Raises:
            RuntimeError: 当模型未训练时抛出异常
        """
        if self.parameters is None:
            raise RuntimeError("模型尚未训练，请先调用fit方法")
        a, b = self.parameters["a"], self.parameters["b"]
        return a * np.exp(b * x)

# 最小可运行示例
if __name__ == "__main__":
    # 构造指数关系数据 y = 2 * exp(0.05x) 并加入轻微噪声
    x = np.arange(0, 100, 10)
    true_a, true_b = 2.0, 0.05
    y = true_a * np.exp(true_b * x)
    
    fitter = ExponentialFitter()
    params = fitter.fit(x, y)
    logger.info(f"拟合参数: a={params['a']:.4f}, b={params['b']:.4f}")
    logger.info(f"R²: {fitter.r_squared:.4f}")
    
    x_new = np.array([15, 55, 95])
    y_pred = fitter.predict(x_new)
    logger.info(f"预测: x={x_new} -> y={y_pred}")
```

### 4.3 机器学习拟合方法

#### 4.3.1 支持向量回归
```python
import numpy as np
import logging
from typing import Union
from sklearn.svm import SVR
from sklearn.preprocessing import StandardScaler
from sklearn.metrics import r2_score

# 配置日志
logger = logging.getLogger(__name__)
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

class SVRFitter:
    """支持向量回归拟合器
    
    使用支持向量机进行非线性回归拟合，适用于复杂的水泵特性曲线建模。
    相比传统多项式拟合，SVR能够更好地处理非线性关系和噪声数据。
    """
    
    def __init__(self, kernel: str = 'rbf', C: float = 1.0, gamma: Union[str, float] = 'scale') -> None:
        """
        初始化SVR拟合器
        
        Args:
            kernel: 核函数类型，'rbf'(径向基函数)适用于大多数曲线拟合
            C: 正则化参数，值越大模型越复杂但可能过拟合
            gamma: 核函数参数，控制单个训练样本的影响范围
            
        注意:
            需要安装 scikit-learn: pip install scikit-learn
        """
        self.scaler_x = StandardScaler()
        self.scaler_y = StandardScaler()
        self.model = SVR(kernel=kernel, C=C, gamma=gamma)
        self.is_fitted = False
        self.r_squared: float = 0.0
        
    def fit(self, x: np.ndarray, y: np.ndarray) -> None:
        """
        训练SVR模型
        
        Args:
            x: 自变量数据，如流量 (m³/h)
            y: 因变量数据，如扬程 (m) 或功率 (kW)
            
        Raises:
            ValueError: 当输入数据长度不匹配时抛出异常
        """
        if len(x) != len(y):
            raise ValueError("x和y数据长度必须相等")
        
        # 数据标准化
        x_scaled = self.scaler_x.fit_transform(x.reshape(-1, 1))
        y_scaled = self.scaler_y.fit_transform(y.reshape(-1, 1)).ravel()
        
        # 训练模型
        self.model.fit(x_scaled, y_scaled)
        self.is_fitted = True
        
        # 计算训练集 R²
        y_pred_scaled = self.model.predict(x_scaled)
        self.r_squared = r2_score(y_scaled, y_pred_scaled)
        
    def predict(self, x: np.ndarray) -> np.ndarray:
        """
        预测新数据点
        
        Args:
            x: 待预测的自变量
            
        Returns:
            预测结果
            
        Raises:
            RuntimeError: 当模型未训练时抛出异常
        """
        if not self.is_fitted:
            raise RuntimeError("模型尚未训练，请先调用fit方法")
        
        x_scaled = self.scaler_x.transform(x.reshape(-1, 1))
        y_scaled = self.model.predict(x_scaled)
        return self.scaler_y.inverse_transform(y_scaled.reshape(-1, 1)).ravel()

# 最小可运行示例
if __name__ == "__main__":
    # 模拟非线性水泵特性曲线数据
    flow = np.array([10, 20, 25, 30, 35, 40, 45, 50, 60])  # 流量 m³/h
    # 非线性扬程特性(二次+三次项)
    head = 120 - 0.8 * flow - 0.01 * flow**2 + 0.0001 * flow**3
    # 添加噪声
    np.random.seed(42)
    head += np.random.normal(0, 1, len(head))
    
    # 创建并训练SVR模型
    svr_fitter = SVRFitter(C=10.0, gamma=0.1)
    svr_fitter.fit(flow, head)
    
    logger.info(f"SVR模型训练完成，R²: {svr_fitter.r_squared:.4f}")
    
    # 预测新流量点
    new_flow = np.array([15, 28, 55])
    predicted_head = svr_fitter.predict(new_flow)
    logger.info(f"流量 {new_flow} m³/h 对应扬程: {predicted_head:.2f} m")
    
    # 对比多项式拟合
    from sklearn.preprocessing import PolynomialFeatures
    from sklearn.linear_model import LinearRegression
    poly_features = PolynomialFeatures(degree=2)
    flow_poly = poly_features.fit_transform(flow.reshape(-1, 1))
    poly_model = LinearRegression().fit(flow_poly, head)
    new_flow_poly = poly_features.transform(new_flow.reshape(-1, 1))
    poly_pred = poly_model.predict(new_flow_poly)
    
    logger.info(f"多项式预测: {poly_pred:.2f} m")
    logger.info("注意: SVR在处理噪声和非线性方面通常表现更好")
```

### 4.4 深度学习拟合方法

#### 4.4.1 神经网络拟合
```python
import torch
import torch.nn as nn
import torch.optim as optim
import numpy as np
import logging
from torch.utils.data import DataLoader, TensorDataset
from typing import Tuple, Optional

# 配置日志
logger = logging.getLogger(__name__)
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

class NeuralNetworkFitter(nn.Module):
    """神经网络曲线拟合器
    
    基于PyTorch的深度神经网络，用于复杂非线性水泵特性曲线建模。
    适用于传统数学方法难以处理的复杂曲线关系，如多峰、不连续等情况。
    
    优势:
        - 强大的非线性拟合能力
        - 自适应特征学习
        - 对噪声数据有一定鲁棒性
    
    注意:
        需要安装 PyTorch: pip install torch
    """
    
    def __init__(self, hidden_size: int = 64, num_layers: int = 3, dropout_rate: float = 0.1) -> None:
        """
        初始化神经网络结构
        
        Args:
            hidden_size: 隐层神经元数量，建议64-256之间
            num_layers: 隐层数量，过多可能过拟合
            dropout_rate: Dropout概率，防止过拟合
            
        Raises:
            ValueError: 当隐层数量小于1或dropout_rate不在[0,1]范围内
        """
        super().__init__()
        
        if num_layers < 1:
            raise ValueError("隐层数量必须至少为1")
        if not 0 <= dropout_rate <= 1:
            raise ValueError("dropout_rate必须在[0,1]范围内")
        
        self.hidden_size = hidden_size
        self.num_layers = num_layers
        self.dropout_rate = dropout_rate
        
        # 构建网络层
        layers = []
        layers.append(nn.Linear(1, hidden_size))
        layers.append(nn.ReLU())
        
        for _ in range(num_layers - 1):
            layers.append(nn.Linear(hidden_size, hidden_size))
            layers.append(nn.ReLU())
            if dropout_rate > 0:
                layers.append(nn.Dropout(dropout_rate))
            
        layers.append(nn.Linear(hidden_size, 1))
        
        self.network = nn.Sequential(*layers)
        self.is_fitted = False
        self.train_loss: float = 0.0
        
    def forward(self, x: torch.Tensor) -> torch.Tensor:
        """
        前向传播计算
        
        Args:
            x: 输入张量，形状为 (batch_size, 1)
            
        Returns:
            预测输出张量，形状为 (batch_size, 1)
        """
        return self.network(x)
    
    def fit(self, x: np.ndarray, y: np.ndarray, epochs: int = 1000, 
            learning_rate: float = 0.001, batch_size: int = 32) -> dict:
        """
        训练神经网络模型
        
        Args:
            x: 自变量数据，如流量 (m³/h)
            y: 因变量数据，如扬程 (m) 或功率 (kW)
            epochs: 训练轮数
            learning_rate: 学习率
            batch_size: 批次大小
            
        Returns:
            训练结果字典，包含最终损失值
            
        Raises:
            ValueError: 当输入数据长度不匹配或为空时
        """
        if len(x) != len(y):
            raise ValueError("x和y数据长度必须相等")
        if len(x) == 0:
            raise ValueError("输入数据不能为空")
        
        # 数据预处理
        x_tensor = torch.FloatTensor(x.reshape(-1, 1))
        y_tensor = torch.FloatTensor(y.reshape(-1, 1))
        
        # 数据标准化
        self.x_mean, self.x_std = x_tensor.mean(), x_tensor.std()
        self.y_mean, self.y_std = y_tensor.mean(), y_tensor.std()
        
        x_normalized = (x_tensor - self.x_mean) / (self.x_std + 1e-8)
        y_normalized = (y_tensor - self.y_mean) / (self.y_std + 1e-8)
        
        # 创建数据加载器
        dataset = torch.utils.data.TensorDataset(x_normalized, y_normalized)
        dataloader = torch.utils.data.DataLoader(dataset, batch_size=batch_size, shuffle=True)
        
        # 优化器和损失函数
        optimizer = optim.Adam(self.parameters(), lr=learning_rate)
        criterion = nn.MSELoss()
        
        # 训练循环
        self.train()
        for epoch in range(epochs):
            epoch_loss = 0.0
            for batch_x, batch_y in dataloader:
                optimizer.zero_grad()
                outputs = self.forward(batch_x)
                loss = criterion(outputs, batch_y)
                loss.backward()
                optimizer.step()
                epoch_loss += loss.item()
            
            if (epoch + 1) % 100 == 0:
                avg_loss = epoch_loss / len(dataloader)
                logger.info(f"Epoch [{epoch+1}/{epochs}], Loss: {avg_loss:.6f}")
        
        self.train_loss = epoch_loss / len(dataloader)
        self.is_fitted = True
        return {"final_loss": self.train_loss}
    
    def predict(self, x: np.ndarray) -> np.ndarray:
        """
        预测新数据点
        
        Args:
            x: 待预测的自变量
            
        Returns:
            预测结果
            
        Raises:
            RuntimeError: 当模型未训练时
        """
        if not self.is_fitted:
            raise RuntimeError("模型尚未训练，请先调用fit方法")
        
        self.eval()
        with torch.no_grad():
            x_tensor = torch.FloatTensor(x.reshape(-1, 1))
            x_normalized = (x_tensor - self.x_mean) / (self.x_std + 1e-8)
            y_normalized = self.forward(x_normalized)
            y_pred = y_normalized * self.y_std + self.y_mean
            return y_pred.numpy().flatten()

# 最小可运行示例
if __name__ == "__main__":
    # 检查PyTorch可用性
    try:
        import torch
        logger.info(f"PyTorch版本: {torch.__version__}")
    except ImportError:
        logger.error("请安装PyTorch: pip install torch")
        exit(1)
    
    # 生成复杂非线性数据（模拟水泵特性曲线）
    np.random.seed(42)
    x_train = np.linspace(10, 100, 50)
    # 复杂的三次+正弦波形
    y_train = 120 - 0.8 * x_train - 0.01 * x_train**2 + 0.0001 * x_train**3 + 5 * np.sin(x_train / 10)
    # 添加噪声
    y_train += np.random.normal(0, 2, len(y_train))
    
    logger.info("开始训练神经网络...")
    
    # 创建并训练模型
    nn_fitter = NeuralNetworkFitter(hidden_size=32, num_layers=2, dropout_rate=0.1)
    training_result = nn_fitter.fit(x_train, y_train, epochs=500, learning_rate=0.01)
    
    logger.info(f"训练完成，最终损失: {training_result['final_loss']:.6f}")
    
    # 预测测试
    x_test = np.array([25, 50, 75])
    y_pred = nn_fitter.predict(x_test)
    
    logger.info("预测结果:")
    for xi, yi in zip(x_test, y_pred):
        logger.info(f"  流量 {xi} m³/h -> 扬程 {yi:.2f} m")
    
    # 与多项式拟合对比
    poly_coeffs = np.polyfit(x_train, y_train, 3)
    y_poly = np.polyval(poly_coeffs, x_test)
    
    logger.info("多项式拟合对比:")
    for xi, yi, yp in zip(x_test, y_pred, y_poly):
        logger.info(f"  流量 {xi} -> 神经网络: {yi:.2f}, 多项式: {yp:.2f}")
    
    logger.info("注意: 神经网络在处理复杂非线性关系方面具有优势")
```

## 5. 实时监控系统

### 5.1 数据采集
- **采集频率**：1Hz（每秒一次）
- **数据源**：CSV文件自动加载
- **缓存机制**：滑动窗口缓存最近1000个数据点

### 5.2 状态监控
```python
class PerformanceMonitor:
    """性能监控器"""
    
    def __init__(self):
        """初始化监控器"""
        self.thresholds = {
            'efficiency_min': 0.6,      # 最低效率阈值
            'vibration_max': 10.0,      # 最大振动阈值
            'temperature_max': 80.0,    # 最高温度阈值
        }
        
    def check_performance(self, data: Dict[str, float]) -> Dict[str, bool]:
        """
        检查性能指标
        
        Args:
            data: 当前运行数据
            
        Returns:
            检查结果字典
        """
        results = {}
        
        # 效率检查
        if 'efficiency' in data:
            results['efficiency_normal'] = data['efficiency'] >= self.thresholds['efficiency_min']
            
        # 振动检查
        if 'vibration' in data:
            results['vibration_normal'] = data['vibration'] <= self.thresholds['vibration_max']
            
        # 温度检查
        if 'temperature' in data:
            results['temperature_normal'] = data['temperature'] <= self.thresholds['temperature_max']
            
        return results
```

## 6. 优化算法

### 6.1 单目标优化
- **遗传算法**：用于非线性优化问题
- **粒子群优化**：适用于连续参数优化
- **模拟退火**：全局优化算法

### 6.2 多目标优化
- **NSGA-II算法**：帕累托最优解集求解
- **目标权重法**：多目标转单目标

## 7. 数据存储与管理

### 7.1 数据模型
```python
@dataclass
class PumpOperationData:
    """泵运行数据模型"""
    timestamp: datetime
    flow_rate: float        # 流量 (m³/h)
    head: float            # 扬程 (m)
    efficiency: float      # 效率 (%)
    power: float          # 功率 (kW)
    frequency: float      # 频率 (Hz)
    vibration: float      # 振动 (mm/s)
    temperature: float    # 温度 (°C)
```

### 7.2 数据验证
```python
def validate_pump_data(data: PumpOperationData) -> bool:
    """
    验证泵运行数据的有效性
    
    Args:
        data: 泵运行数据
        
    Returns:
        数据是否有效
    """
    # 范围检查
    if not (0 <= data.efficiency <= 1.0):
        return False
        
    if not (0 <= data.flow_rate <= 1000):
        return False
        
    if not (0 <= data.head <= 200):
        return False
        
    return True
```

## 8. 质量保证

### 8.1 测试规范
- **单元测试**：覆盖率 ≥ 80%
- **集成测试**：关键路径全覆盖
- **性能测试**：响应时间 < 1s

### 8.2 代码规范
- **类型注解**：所有公开函数必须有类型注解
- **文档字符串**：中文注释，说明参数、返回值、异常
- **错误处理**：具体异常捕获，避免裸except

## 9. 部署与运维

### 9.1 环境要求
- **Python版本**：3.13.6
- **依赖管理**：pyproject.toml
- **虚拟环境**：.venv

### 9.2 配置管理
```python
@dataclass
class SystemConfig:
    """系统配置类"""
    data_path: str = "data/"
    log_level: str = "INFO"
    max_data_points: int = 10000
    fitting_algorithm: str = "polynomial"
    optimization_method: str = "genetic"
```

## 10. 日志规范
```python
import logging

# 配置中文日志
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler('pump_system.log', encoding='utf-8'),
        logging.StreamHandler()
    ]
)

logger = logging.getLogger(__name__)

# 使用示例
logger.info("开始执行曲线拟合，数据点数：%d", len(data))
logger.error("拟合失败：%s", str(e))
```

---

**备注**：本规范基于实际项目需求制定，着重于CSV数据处理和性能优化，删除了复杂的物理建模方法，简化了系统架构，更适合当前项目规模。