______________________________________________________________________

## globs: *.py,*.md,\*.sql description: 通用代码规范（单一职责、文件/函数大小、完整注释、命名、错误处理、日志、安全、并发/资源、测试、格式化）

# 通用代码规范

本规范适用于本项目所有代码与文档（以 Python 为主），确保代码可读、可维护、可扩展、稳定可靠。

## 1. 设计与原则

- 单一职责（SRP）: 每个模块/类/函数只做一类清晰的事。超过一个强耦合职责应拆分。
- KISS: 选择最简单可用的实现，避免过度抽象、反射与魔法。
- DRY: 杜绝重复代码；共性逻辑上移到 `utils/` 或独立函数。
- 最少惊讶: API 行为直观、一致；避免隐式副作用。
- 可观察性优先: 重要路径必须可监测（日志/指标），便于回溯问题。

## 2. 文件与模块

- 文件大小: 单文件建议 ≤ 500 行；>800 行必须拆分（特殊生成代码除外）。
- 模块边界: 一个文件聚焦一个领域概念；跨层逻辑走既定网关（如 `app/db/gateways.py`）。
- 公开接口: 每模块公开 API 限制在 3-7 个；其余设为内部（前缀 `_`）。
- 文件头部注释（必须）: 描述模块职责、关键依赖以及使用示例。

示例（文件头部注释）:

```python
"""
模块: csv_loader
职责: 使用 LOAD DATA LOCAL INFILE 将 CSV 导入临时表 tmp_raw，并提供去重后的视图。
依赖: app/db/mysql_pool, app/db/sql_snippets
用法:
    loader = CsvLoader(conn_pool)
    with loader.load_to_temp("data/a.csv") as tmp:
        loader.dedup_seconds(tmp)
"""
```

## 3. 函数与类

- 函数长度: 建议 ≤ 50 行；>80 行必须拆分；圈复杂度 ≤ 10。
- 参数个数: 建议 ≤ 5；更多请封装为配置/数据类。
- 返回值: 明确、文档化；错误返回不要用魔法值，使用异常或 Result 对象。
- 类设计: 组合优先于继承；避免深层继承链；构造后保持可用态。

## 4. 注释与文档（必须“完整注释”）

- 模块/公开函数/类必须有 docstring（Google 或 NumPy 风格），项目内保持一致。
- 注释写“为什么/约束/边界”，而非复述代码。
- 参数/返回/异常/副作用必须说明；给出最小可运行示例（如适用）。
- 必须中文注释。

Docstring 模板（Google 风格）:

```python
def merge_json_fields(existing: dict, patch: dict) -> dict:
    """使用 JSON_MERGE_PATCH 语义合并字段。

    Args:
        existing: 现有 JSON（数据库读出/空字典）。
        patch: 新增/更新字段的 JSON 片段。

    Returns:
        合并后的 JSON 对象，不修改入参。

    Raises:
        ValueError: 当 patch 含非法字段名或类型不满足约束。
    """
```

## 5. 命名规范

- 模块/包: 小写蛇形；类: 大驼峰；函数/变量: 小写蛇形；常量: 全大写下划线。
- 命名体现含义而非实现细节：`load_csv_to_temp_table` 优于 `handle_file`。
- 标识外部语义的变量包含单位或维度（如 `flow_rate_m3h`）。

## 6. 导入顺序与格式化

- 导入顺序: 标准库 → 第三方 → 本地；每组内按字母序；避免通配符导入。
- 建议工具: `isort`（导入排序）、`black`（格式化）、`ruff/flake8`（lint）。
- 行宽 ≤ 100；统一编码 UTF-8；换行 `\n`（Windows 下工具需兼容）。

示例（isort 配置片段）:

```ini
[tool.isort]
profile = "black"
line_length = 100
```

## 7. 静态与类型检查

- 对外暴露的模块/函数必须有类型注解；内部可依赖推断。
- 推荐启用 `mypy` 对关键模块进行检查；避免 `Any` 与不安全类型转换。

## 8. 错误处理与异常

- 禁止裸 `except:`；必须捕获特定异常类型；禁止吞异常。
- 边界层（CLI/任务入口）做兜底捕获，记录上下文与输入关键信息。
- 与 MySQL 交互：区分可重试（1213/1205/2006/2013）与不可重试（1064/1146/1054/1364/1062），前者指数退避（见 44）。

日志与异常示例:

```python
try:
    save_batch(rows)
except DeadlockError as e:
    logger.warning("db.retry", extra={"error_code":1213, "attempt":attempt, "backoff_ms":backoff})
    raise
except Exception as e:
    logger.error("task.fail", exc_info=True, extra={"trace_id":trace_id, "hint":"检查入参/连接"})
    raise
```

## 9. 日志与结构化输出

- 使用结构化日志（见 10）；在批处理路径记录 `rows_* / cost_ms / affected_rows`；
- 严禁记录敏感信息（密码/连接串/PII）。

## 10. SQL 与数据访问

- 严禁字符串拼接 SQL；统一使用参数化，占位符 `%s`；
- 事务小批提交；单事务耗时超阈自动拆分（见 20/40）。

SQL 参数化示例:

```python
sql = "SELECT standard_time FROM aligned_data WHERE device_id=%s AND standard_time BETWEEN %s AND %s"
cursor.execute(sql, (device_id, since_dt, until_dt))
```

## 11. 并发与资源

- IO 密集优先线程/协程，CPU 密集优先进程；
- 使用上下文管理器管理连接/游标/文件句柄；异常也能释放；
- 并发与批次按 20/40 自适应规则动态调整，避免长事务与锁冲突。

## 12. 模块模板

```python
"""模块职责与用法简述"""
from __future__ import annotations
from typing import Iterable, Sequence

__all__ = ["public_api"]

class Service:
    def __init__(self, config: dict) -> None:
        self.config = config

    def public_api(self, rows: Sequence[dict]) -> int:
        """处理一批数据并返回影响行数。"""
        return len(rows)
```

## 13. 测试与覆盖率

- 公共函数/模块必须有测试，覆盖典型与边界场景；
- 集成/E2E: 导入→去重→合并→验收；断点续跑场景必须覆盖。

## 14. pre-commit 与 CI

- 建议使用 `pre-commit` 集成 `black/isort/ruff/mypy/secret-scan`；
- CI 执行 lint/type/test 与小样本 e2e（dry-run），禁止跳过。

示例（.pre-commit-config.yaml 片段）:

```yaml
repos:
  - repo: https://github.com/psf/black
    rev: 24.3.0
    hooks: [{id: black}]
  - repo: https://github.com/pycqa/isort
    rev: 5.13.2
    hooks: [{id: isort}]
  - repo: https://github.com/astral-sh/ruff-pre-commit
    rev: v0.4.2
    hooks: [{id: ruff}]
```

## 15. 性能与安全

- 避免一次性载入超大文件；优先流式/块式处理；
- 避免在热路径频繁创建大对象/正则；
- 路径与输入来自白名单（见 app.yaml `security.allow_paths`）；禁止任意拼接未校验路径；
- 严禁提交凭据；使用 `.env` 与环境变量注入。

## 16. 文档与示例

- README 必含：环境准备、运行命令（含 `--dry-run/--resume`）、性能建议、常见错误排查；
- CLI 命令自带 `--help` 完整说明；示例命令可直接复制运行。

## 17. 提交与评审

- 小步提交：单次提交聚焦单一改动；提交信息使用“动词+范围+结果”。
- 评审检查清单：是否单一职责、是否有完整注释、是否批量导入、是否遵循幂等与对齐策略、是否有测试。

## 18. 缩进与换行（强约束）

- 保持文件现有缩进字符（tab vs 空格）与宽度，不转换、不混用；
- 不额外增加无意义缩进层级；
- 换行统一 `\n`（Windows 工具需兼容），避免混入 `\r\n`。

## 19. 配置访问与全局状态

- 通过集中 `settings`/配置对象传入依赖，禁止在业务代码中散落读取 ENV；
- 禁止可变的全局单例；如需缓存，使用受控的 LRU/上下文绑定。

配置注入示例:

```python
class ImportJob:
    def __init__(self, settings: dict, conn_pool):
        self.settings = settings
        self.pool = conn_pool
```

## 20. 并发与连接池

- 每线程/协程应从连接池借还连接；连接/游标使用 `with` 上下文确保释放；
- 线程适合 IO 密集（LOAD/网络），进程适合 CPU 密集；
- DB 连接对象不跨进程复用；跨多进程需在子进程内重建连接。

## 21. 日志适配器模板

```python
import logging
logger = logging.getLogger(__name__)

def with_ctx(extra: dict):
    return logging.LoggerAdapter(logger, extra)

# 使用
log = with_ctx({"trace_id": trace_id, "job_id": job_id})
log.info("ingest.load.begin", extra={"file_path": path})
```

## 22. CLI 模板（typer）

```python
import typer
app = typer.Typer()

@app.command()
def import_station(name: str, concurrency: int = 4, dry_run: bool = False):
    """按泵站导入"""
    # 参数校验与执行...

if __name__ == "__main__":
    app()
```

## 23. 测试与 DB mock

- 关键路径使用 `pytest` + fixture；DB 交互可用临时库/容器或 mock 网关接口；
- 尽量避免对真实生产库的依赖；
- 黄金样本与基线对比参见 213。

## 24. 反模式清单（禁止）

- 字符串拼接 SQL、裸 except、吞异常、print 调试、在热路径频繁 new 大对象；
- 在模块导入顶部执行重 IO/重计算；
- 直接读写随机路径（绕过 `security.allow_paths`）；
- 未校验的用户输入直通 DB 或文件系统；
- 将临时调试开关/路径硬编码进代码。

## 25. 输入校验与数据模型

- 推荐使用 `dataclasses`（零依赖）或 `pydantic`（更强校验）描述入参；
- CLI/业务入口先校验，再执行业务逻辑。

示例（dataclasses）:

```python
from dataclasses import dataclass
from datetime import datetime

@dataclass
class ImportArgs:
    station_name: str
    since: datetime
    until: datetime
```

## 26. 时间与时区

- 本项目“默认不做时区转换”（见 40）；统一秒级精度；
- 解析/格式化使用固定格式 `%Y-%m-%d %H:%M:%S`；避免对 naive datetime 做加减。

示例:

```python
from datetime import datetime
FMT = "%Y-%m-%d %H:%M:%S"
parsed = datetime.strptime(ts_str.split(".")[0], FMT)
```

## 27. 文件与路径

- 使用 `pathlib`，禁止拼接未校验路径；
- 读取 CSV 指定 `encoding='utf-8', newline=''`；
- 大文件采用流式/分块处理。

示例:

```python
from pathlib import Path
p = Path("data") / "a.csv"
with p.open("r", encoding="utf-8", newline="") as f:
    for line in f:
        ...
```

## 28. JSON、精度与单位转换

- 写入前统一舍入（见 32），序列化使用紧凑分隔，避免多余空格；
- 单位转换放 `app/units/`，通过映射表确保一致。

示例:

```python
import json
json.dumps(obj, ensure_ascii=False, separators=(",", ":"))
```

## 29. 重试与超时

- 仅对“幂等”步骤做重试；指数退避、带抖动（见 44）；
- 重要 IO/DB 调用设置超时，避免阻塞。

示例（tenacity）:

```python
from tenacity import retry, stop_after_attempt, wait_exponential_jitter

@retry(stop=stop_after_attempt(5), wait=wait_exponential_jitter(0.2, 2.0))
def write_batch(rows):
    ...
```

## 30. 资源与取消

- 统一用上下文管理器，必要时用 `ExitStack`；
- 响应中断信号，优雅退出并输出 `task.summary`。

## 31. 日志级别与结构

- DEBUG：开发细节；INFO：关键节点/统计；WARN：可恢复异常；ERROR/CRITICAL：失败；
- 使用 `extra={}` 传上下文；避免 f-string 组装大字符串。

## 32. 常量命名与配置

- 常量使用 `UPPER_SNAKE_CASE`；
- 配置从集中 settings 注入，避免散落读取 ENV。

## 33. 包结构与 __init__

- 包内 `__init__.py` 定义 `__all__`；
- 禁止在导入期执行重 IO/重计算。

## 36. 提交前 Checklist（最小集）

- [ ] 类型/静态检查通过（ruff/mypy/black/isort）；
- [ ] 单元/小样本 e2e 通过；
- [ ] SQL 参数化、无裸 except、无明文敏感信息；
- [ ] 日志/指标/错误码符合 10/24/48/57；
- [ ] 规则/文档已更新（必要时）。

## 37. 秘密检测与脱敏

- 代码与提交前必须进行秘密扫描；对日志/异常中的疑似秘密做统一脱敏（见 10）。
- pre-commit 建议增加 `detect-secrets` 或 `gitleaks` 钩子；误报列入受控白名单。

示例（pre-commit 片段）:

```yaml
- repo: https://github.com/Yelp/detect-secrets
  rev: v1.5.0
  hooks: [{id: detect-secrets, args: ["--baseline", ".secrets.baseline"]}]
```

## 38. 依赖与版本固定

- 所有依赖需固定版本；建议 `requirements.in` + `pip-tools` 生成 `requirements.txt`；
- 对安全修复采用最小升级，保留变更单与回滚方案。

示例（pip-tools）:

```bash
pip-compile requirements.in -o requirements.txt
pip-sync requirements.txt
```

## 39. 包与导入规范

- 禁止跨层相对导入（`from ..x import y`）；优先绝对导入；
- `__main__` 入口仅做 CLI 解析与调度，不写业务逻辑。

## 40. ruff/mypy/black 推荐配置

```toml
# pyproject.toml
[tool.black]
line-length = 100

[tool.ruff]
line-length = 100
select = ["E", "F", "I", "B", "UP"]
ignore = ["E501"]

[tool.mypy]
python_version = "3.10"
warn_unused_ignores = true
warn_return_any = true
no_implicit_optional = true
strict_optional = true
```

## 41. trace_id 传递（contextvars）

```python
import contextvars
trace_id_var = contextvars.ContextVar("trace_id", default=None)

def set_trace_id(tid: str):
    trace_id_var.set(tid)

def get_trace_id() -> str | None:
    return trace_id_var.get()
```

- 日志适配器读取 `get_trace_id()`，在多线程/协程场景保持一致（见 217）。

## 42. 重试边界与熔断

- 仅在幂等点重试；对持续失败的下游启用熔断与冷却（见 62/44）。

示例（简单熔断）:

```python
from time import monotonic
open_until = 0.0

def call_downstream():
    global open_until
    now = monotonic()
    if now < open_until:
        raise RuntimeError("circuit-open")
    try:
        return do_request()
    except Exception:
        open_until = now + 30  # 冷却 30s
        raise
```

## 43. 流式读写与内存守护

- 读取超大 CSV 时使用分块/迭代器；避免将整文件读入内存；
- 构造中间集合前先估算大小与上限，必要时落盘临时文件。

## 44. 数据校验模式

- 时间字符串需严格匹配 `%Y-%m-%d %H:%M:%S`；
- 数值字段必须可解析为 `Decimal`，失败入坏行（见 47/31）。

## 45. 文档与示例可执行性

- 文档中的代码片段应可直接运行；示例命令可复制粘贴；
- 对关键规则在文档中给出“反例”以提示常见错误。
