# ä¼˜åŒ–ç®—æ³•ä¸å‚æ•°è°ƒä¼˜æŠ€æœ¯è§„èŒƒ

> ç›®æ ‡ï¼šå°†åŸæœ‰æŠ€æœ¯è§„èŒƒä¸­"ä¼˜åŒ–ç®—æ³•ä¸å‚æ•°è°ƒä¼˜"åŠ"æ³µç»„ä¼˜åŒ–ç®—æ³•è§„èŒƒ"çš„å†…å®¹æŠ½ç¦»ä¸ºç‹¬ç«‹æ–‡æ¡£ï¼Œç»Ÿä¸€æè¿°ä¼˜åŒ–é—®é¢˜å»ºæ¨¡ã€ç®—æ³•é€‰æ‹©ã€å‚æ•°è°ƒä¼˜ä¸å·¥ç¨‹åŒ–è½åœ°ï¼Œå‡å°‘ä¸»æ–‡æ¡£è¡Œæ•°å¹¶æå‡å¯ç»´æŠ¤æ€§ã€‚

## å¦‚ä½•ä½¿ç”¨æœ¬è§„èŒƒ

### ğŸ¯ æ–°å…¥èŒç®—æ³•å·¥ç¨‹å¸ˆå¿«é€Ÿå¯åŠ¨

1. **ç†Ÿæ‚‰ä¼˜åŒ–é—®é¢˜å»ºæ¨¡**ï¼šé˜…è¯»ç¬¬2ç« ï¼Œç†è§£å†³ç­–å˜é‡ã€ç›®æ ‡å‡½æ•°ã€çº¦æŸå®šä¹‰æ–¹å¼
1. **é€‰æ‹©åˆé€‚ç®—æ³•**ï¼šæ ¹æ®é—®é¢˜ç‰¹å¾ï¼ˆå•/å¤šç›®æ ‡ã€è¿ç»­/ç¦»æ•£ï¼‰é€‰æ‹©ç¬¬3-4ç« å¯¹åº”ç®—æ³•
1. **å®ç°æ³µç»„ä¼˜åŒ–**ï¼šå‚è€ƒç¬¬5ç« çš„å®é™…åº”ç”¨åœºæ™¯ä¸ç®—æ³•é›†æˆæ–¹æ¡ˆ
1. **å‚æ•°è°ƒä¼˜å®è·µ**ï¼šæŒ‰ç¬¬6ç« æµç¨‹è¿›è¡Œå‚æ•°æœç´¢ä¸æ€§èƒ½è¯„ä¼°

### ğŸ“‹ æ—¥å¸¸å¼€å‘æ£€æŸ¥æ¸…å•

- [ ] ä¼˜åŒ–é—®é¢˜æ˜¯å¦æŒ‰ç¬¬2ç« æ¥å£çº¦å®šå®ç°ï¼ˆobjective/constraints/boundsï¼‰
- [ ] ç®—æ³•é€‰æ‹©æ˜¯å¦è€ƒè™‘é—®é¢˜è§„æ¨¡ä¸æ”¶æ•›è¦æ±‚
- [ ] å‚æ•°è°ƒä¼˜æ˜¯å¦éµå¾ªç¬¬6ç« çš„ç³»ç»ŸåŒ–æµç¨‹
- [ ] ç»“æœè¯„ä¼°æ˜¯å¦åŒ…å«ç¬¬7ç« è¦æ±‚çš„å¯è§†åŒ–ä¸ç»Ÿè®¡åˆ†æ
- [ ] é…ç½®ç®¡ç†æ˜¯å¦æŒ‰ç¬¬8ç« è§„èŒƒåŒ–ï¼ˆå¯å¤ç°ã€ç‰ˆæœ¬æ§åˆ¶ï¼‰

### ğŸ” å¸¸è§é—®é¢˜å¿«é€Ÿå¯¼èˆª

- **å¤šç›®æ ‡æƒè¡¡å†³ç­–** â†’ ç¬¬4ç«  NSGA-II ä¸å¸•ç´¯æ‰˜å‰æ²¿åˆ†æ
- **ç®—æ³•æ”¶æ•›æ€§é—®é¢˜** â†’ ç¬¬6ç« åœæ­¢å‡†åˆ™ä¸æ—©åœç­–ç•¥
- **å‚æ•°æ•æ„Ÿæ€§åˆ†æ** â†’ ç¬¬7ç« æ•æ„Ÿæ€§è¯„ä¼°æ–¹æ³•
- **å·¥ç¨‹åŒ–éƒ¨ç½²é…ç½®** â†’ ç¬¬8ç« é…ç½®æ¨¡å‹ä¸æ—¥å¿—è§„èŒƒ

______________________________________________________________________

## 1. é€‚ç”¨èŒƒå›´ä¸æœ¯è¯­

- é€‚ç”¨èŒƒå›´ï¼šæ°´æ³µ/æ³µç«™è¿è¡Œç­–ç•¥ä¼˜åŒ–ã€æ›²çº¿æ‹Ÿåˆå‚æ•°åæ±‚ã€ç³»ç»Ÿèƒ½æ•ˆä¼˜åŒ–ä¸å¤šç›®æ ‡æƒè¡¡ã€‚
- æœ¯è¯­çº¦å®šï¼š
  - å†³ç­–å˜é‡ xï¼šè¿ç»­æˆ–ç¦»æ•£å‚æ•°ï¼Œå«è¿è¡Œç‚¹ã€å¯åœç»„åˆã€é¢‘ç‡/é˜€ä½ç­‰ã€‚
  - ç›®æ ‡å‡½æ•° f(x)ï¼šå•ç›®æ ‡æˆ–å¤šç›®æ ‡ï¼ˆèƒ½è€—ã€æ•ˆç‡ã€ç£¨æŸã€ç¨³å®šæ€§ï¼‰ã€‚
  - çº¦æŸ g(x) â‰¤ 0, h(x) = 0ï¼šæµé‡/å‹åŠ›/å®¹é‡/è¿è¡Œè¾¹ç•Œ/æ£€ä¿®çª—å£ç­‰ã€‚

## 2. ä¼˜åŒ–é—®é¢˜å»ºæ¨¡

- å†³ç­–ç©ºé—´ï¼šç”± OptimizationBounds å®šä¹‰ä¸Šä¸‹ç•Œä¸ç»´åº¦ï¼›ç¦»æ•£å˜é‡å»ºè®®ç¼–ç ä¸ºæ•´æ•°å¹¶åœ¨ç®—å­ä¸­åšå‹å€¼ä¿®å¤ã€‚
- ç›®æ ‡å®šä¹‰ï¼šæ”¯æŒæœ€å°åŒ–/æœ€å¤§åŒ–ï¼›å¤šç›®æ ‡æ—¶è¾“å‡ºå‘é‡å¹¶é‡‡ç”¨å¸•ç´¯æ‰˜æ”¯é…å…³ç³»ã€‚
- çº¦æŸå¤„ç†ï¼š
  - è½¯çº¦æŸï¼šç½šå‡½æ•°/å¯è¡Œæ€§ä¼˜å…ˆæ’åºã€‚
  - ç¡¬çº¦æŸï¼šè§£ä¿®å¤ã€è¾¹ç•ŒæŠ•å½±ã€å¯è¡Œæ€§ä¿æŒç®—å­ã€‚
- æ¥å£çº¦å®šï¼š
  - objective(x: ndarray) -> float | dict\[str, float\]
  - constraints(x: ndarray) -> dict\[str, bool\]
  - bounds: OptimizationBounds(lower: list\[float\], upper: list\[float\])

## 3. å•ç›®æ ‡å…¨å±€ä¼˜åŒ–ç®—æ³•

- é—ä¼ ç®—æ³•ï¼ˆGeneticAlgorithmOptimizerï¼‰
  - å…³é”®é˜¶æ®µï¼šç§ç¾¤åˆå§‹åŒ–â†’é€‚åº”åº¦è¯„ä¼°â†’é€‰æ‹©ï¼ˆé”¦æ ‡èµ›/è½®ç›˜èµŒï¼‰â†’äº¤å‰ï¼ˆå•ç‚¹/å‡åŒ€/SBXï¼‰â†’å˜å¼‚ï¼ˆå¤šé¡¹å¼/é«˜æ–¯ï¼‰â†’è¾¹ç•Œä¿®å¤ã€‚
  - å¯è°ƒå‚ï¼špopulation_size, generations, crossover_rate, mutation_rate, elitismã€‚
  - æ”¶æ•›ç›‘æ§ï¼šæœ€ä¼˜å€¼æ›²çº¿ã€ç§ç¾¤å¤šæ ·æ€§ã€æ—©åœï¼ˆé˜ˆå€¼/è€å¿ƒï¼‰ã€‚
- ç²’å­ç¾¤ä¼˜åŒ–ï¼ˆParticleSwarmOptimizerï¼‰
  - å‚æ•°ï¼šw, c1, c2ï¼Œé€Ÿåº¦ä¸Šé™ v_maxï¼Œä½ç½®è¾¹ç•ŒæŠ•å½±ã€‚
  - ç­–ç•¥ï¼šçº¿æ€§é€’å‡æƒ¯æ€§æƒé‡/è‡ªé€‚åº”æƒé‡ï¼Œå±€éƒ¨/å…¨å±€é‚»åŸŸæ‹“æ‰‘ã€‚
- è´å¶æ–¯ä¼˜åŒ–ï¼ˆBayesianOptimizerï¼‰
  - æ ¸å¿ƒï¼šé«˜æ–¯è¿‡ç¨‹å›å½’å™¨ + é‡‡é›†å‡½æ•°ï¼ˆEI/PI/UCBï¼‰ã€‚
  - æŠ€å·§ï¼šæ ‡å‡†åŒ–è¾“å…¥/è¾“å‡ºã€é‡å¤å¯åŠ¨ n_restartsã€é‡‡é›†å‡½æ•°æœ€å¤§åŒ–ä½¿ç”¨è¾¹ç•Œä¸éšæœºé‡å¯ã€‚

## 4. å¤šç›®æ ‡ä¼˜åŒ–ï¼ˆNSGA-IIï¼‰

- æµç¨‹ï¼šéæ”¯é…æ’åºâ†’æ‹¥æŒ¤è·ç¦»â†’é”¦æ ‡èµ›é€‰æ‹©â†’SBXäº¤å‰â†’å¤šé¡¹å¼å˜å¼‚â†’ç¯å¢ƒé€‰æ‹©ã€‚
- æŒ‡æ ‡ï¼š
  - å¸•ç´¯æ‰˜å‰æ²¿è¿‘ä¼¼è´¨é‡ä¸åˆ†å¸ƒå‡åŒ€æ€§ã€‚
  - è¶…ä½“ç§¯ï¼ˆHypervolumeï¼Œâ‰¤3 ç›®æ ‡æ—¶ç®€åŒ–è®¡ç®—ï¼‰ã€‚
- å®è·µå»ºè®®ï¼šä¿æŒè¶³å¤Ÿç§ç¾¤è§„æ¨¡ä¸ä»£æ•°ï¼Œå¿…è¦æ—¶å¯å‘å¼é‡å¯ä»¥é¿å…æ—©ç†Ÿæ”¶æ•›ã€‚

## 5. æ³µç»„ä¼˜åŒ–ç®—æ³•è§„èŒƒ

- ä¼˜åŒ–ç›®æ ‡ï¼š
  - èƒ½è€—æœ€å°åŒ–ï¼šmin Î£ P_i(t)
  - æ•ˆç‡æœ€å¤§åŒ–ï¼šmax Î£ Î·_i(t)Â·Q_i(t)
  - ç£¨æŸæœ€å°åŒ–ï¼šmin Î£ wear_rate_i(t)
  - ç¨³å®šæ€§æœ€å¤§åŒ–ï¼šmin Î£ vibration_i(t)
- ç®—æ³•é›†æˆï¼š
  - ç»å…¸ï¼šNelderâ€“Meadã€æ¢¯åº¦ã€BFGS/Newtonï¼ˆå¯ç”¨äºè¿ç»­å¯å¯¼å­é—®é¢˜çš„ç²¾ä¿®ï¼‰ã€‚
  - å¯å‘å¼ï¼šGA/PSO/å·®åˆ†è¿›åŒ–/æ¨¡æ‹Ÿé€€ç«/èšç¾¤ï¼ˆé€‚åˆéå‡¸ã€ç¦»æ•£æ··åˆï¼‰ã€‚
  - å¼ºåŒ–å­¦ä¹ ï¼šPPO/DDPG ç­‰åœ¨æ³µç«™ç¯å¢ƒä¸Šè¿›è¡Œç­–ç•¥å­¦ä¹ ï¼Œç”¨äºåœ¨çº¿/è¿‘å®æ—¶å†³ç­–ã€‚
- çº¦æŸå¤„ç†ä¸è§£ä¿®å¤ï¼š
  - æµé‡éœ€æ±‚ã€å‹åŠ›è¦æ±‚ã€æ³µå‹/å°æ•°å®¹é‡ã€è¿è¡Œä¸Šä¸‹é™ã€æ£€ä¿®è®¡åˆ’ã€‚
  - ç»Ÿä¸€çš„ ConstraintHandlerï¼švalidate_solution â†’ repair_solutionã€‚

## 6. å‚æ•°è°ƒä¼˜ä¸åœæ­¢å‡†åˆ™

- è°ƒå‚æµç¨‹ï¼š
  1. ç¡®å®šæœç´¢ç©ºé—´ï¼ˆå¯¹æ•°/çº¿æ€§å°ºåº¦ï¼‰ï¼›
  1. ç²—ç²’åº¦ç½‘æ ¼/éšæœºæœç´¢é¢„ç­›ï¼›
  1. è´å¶æ–¯ä¼˜åŒ–ç²¾ä¿®ï¼ˆä»¥éªŒè¯æŒ‡æ ‡ä¸ºç›®æ ‡ï¼‰ï¼›
  1. äº¤å‰éªŒè¯ä¸é²æ£’æ€§è¯„ä¼°ï¼ˆå¤šéšæœºç§å­ï¼‰ã€‚
- åœæ­¢å‡†åˆ™ï¼š
  - è¿­ä»£ä¸Šé™ã€æ— æ”¹è¿›è½®æ•°ã€ç›®æ ‡é˜ˆå€¼è¾¾æˆã€é¢„ç®—ï¼ˆæ—¶é—´/è¯„ä¼°æ¬¡æ•°ï¼‰ã€‚
- å¤ç°æ€§ï¼šå›ºå®šéšæœºç§å­ã€è®°å½•é…ç½®å¿«ç…§ä¸æ•°æ®ç‰ˆæœ¬ã€‚

## 7. ç»“æœè¯„ä¼°ä¸å¯è§†åŒ–

- å•ç›®æ ‡ï¼šæœ€ä¼˜å€¼æ›²çº¿ã€å‚æ•°æ”¶æ•›è½¨è¿¹ã€æ•æ„Ÿæ€§åˆ†æï¼ˆåå¯¼/æ‰°åŠ¨ï¼‰ã€‚
- å¤šç›®æ ‡ï¼šå¸•ç´¯æ‰˜å‰æ²¿æ•£ç‚¹ã€è¶…ä½“ç§¯éšä»£æ•°å˜åŒ–ã€ç›®æ ‡é—´æƒè¡¡æ›²çº¿ã€‚
- è¿è¡Œç»Ÿè®¡ï¼š
  - è¯„ä¼°æ¬¡æ•°ã€è¿­ä»£è€—æ—¶ã€å¤±è´¥/ä¿®å¤æ¯”ç‡ã€å¯è¡Œè§£æ¯”ä¾‹ã€‚

## 8. å·¥ç¨‹åŒ–ä¸é…ç½®

- é…ç½®æ¨¡å‹ï¼ˆç¤ºä¾‹å­—æ®µï¼‰ï¼š
  - GAï¼špopulation_size, generations, crossover_rate, mutation_rate, elitismã€‚
  - PSOï¼šswarm_size, inertia_w, c1, c2, v_maxã€‚
  - BOï¼škernel, acquisition_function, initial_points, n_restarts_optimizerã€‚
  - NSGA-IIï¼špopulation_size, generations, crossover_rate, mutation_rateã€‚
- ç»Ÿä¸€æ—¥å¿—ï¼šè®°å½•ç®—æ³•ã€å‚æ•°ã€çº¦æŸã€ç»“æœä¸è€—æ—¶ï¼ˆä¸­æ–‡æ—¥å¿—ï¼‰ã€‚
- å¤±è´¥æ¢å¤ï¼šå®šæœŸå¿«ç…§ï¼ˆcheckpointï¼‰ï¼Œæ”¯æŒä»æœ€è¿‘ä¸–ä»£/è¿­ä»£ç»­è·‘ã€‚

## 9. é™„å½•ï¼šæ¥å£ä¸æ•°æ®ç»“æ„çº¦å®šï¼ˆç¤ºæ„ï¼‰

```python
# å†³ç­–ç©ºé—´è¾¹ç•Œ
@dataclass
class OptimizationBounds:
    lower: list[float]
    upper: list[float]

# ç›®æ ‡å‡½æ•°çº¦å®šï¼ˆå•ç›®æ ‡ï¼‰
# def objective(x: np.ndarray) -> float: ...

# ç›®æ ‡å‡½æ•°çº¦å®šï¼ˆå¤šç›®æ ‡ï¼‰
# def objectives(x: np.ndarray) -> dict[str, float]:
#     return {"energy": energy_cost, "efficiency": -eff, "wear": wear, "stability": vib}

# çº¦æŸåè®®
# def constraints(x: np.ndarray) -> dict[str, bool]:
#     return {"flow_demand": True, "pressure_requirement": True}
```

## 10. å®Œæ•´å¯æ‰§è¡Œç®—æ³•ç¤ºä¾‹

### 10.1 é—ä¼ ç®—æ³•å®ç°

```python
"""
é—ä¼ ç®—æ³•ä¼˜åŒ–å™¨
æ”¯æŒè¿ç»­å˜é‡ä¼˜åŒ–ï¼ŒåŒ…å«é€‰æ‹©ã€äº¤å‰ã€å˜å¼‚ç­‰åŸºæœ¬æ“ä½œ
"""
import numpy as np
import logging
from typing import Dict, Any, Optional, Callable, List, Tuple
from dataclasses import dataclass
import matplotlib.pyplot as plt
from concurrent.futures import ThreadPoolExecutor
import time

# æ—¥å¿—åˆå§‹åŒ–ï¼ˆç¤ºä¾‹ä»£ç ä½¿ç”¨è€…å¯æŒ‰éœ€è°ƒæ•´ï¼‰
logger = logging.getLogger(__name__)

@dataclass
class GAConfig:
    """é—ä¼ ç®—æ³•é…ç½®å‚æ•°"""
    population_size: int = 50
    generations: int = 100
    crossover_rate: float = 0.8
    mutation_rate: float = 0.1
    elitism: int = 2  # ç²¾è‹±ä¸ªä½“æ•°é‡
    tournament_size: int = 3
    early_stopping_patience: int = 20
    early_stopping_threshold: float = 1e-6
    random_seed: Optional[int] = None
    n_jobs: int = 1  # å¹¶è¡Œè¯„ä¼°ä»»åŠ¡æ•°

class GeneticAlgorithmOptimizer:
    """
    é—ä¼ ç®—æ³•ä¼˜åŒ–å™¨

    ç”¨äºæ±‚è§£è¿ç»­å˜é‡ä¼˜åŒ–é—®é¢˜ï¼Œæ”¯æŒå•ç›®æ ‡æœ€å°åŒ–
    """

    def __init__(self, config: GAConfig):
        """
        åˆå§‹åŒ–é—ä¼ ç®—æ³•ä¼˜åŒ–å™¨

        å‚æ•°:
            config: ç®—æ³•é…ç½®å‚æ•°
        """
        self.config = config
        self.best_fitness_history: List[float] = []
        self.diversity_history: List[float] = []
        self.generation = 0

        if config.random_seed is not None:
            np.random.seed(config.random_seed)

    def initialize_population(self, bounds: 'OptimizationBounds') -> np.ndarray:
        """
        åˆå§‹åŒ–ç§ç¾¤

        å‚æ•°:
            bounds: å†³ç­–å˜é‡è¾¹ç•Œ

        è¿”å›:
            åˆå§‹ç§ç¾¤çŸ©é˜µ (population_size, n_variables)
        """
        n_vars = len(bounds.lower)
        population = np.random.uniform(
            low=bounds.lower,
            high=bounds.upper,
            size=(self.config.population_size, n_vars)
        )

        logger.info(f"åˆå§‹åŒ–ç§ç¾¤å®Œæˆï¼Œç§ç¾¤å¤§å°: {self.config.population_size}, å˜é‡ç»´åº¦: {n_vars}")
        return population

    def evaluate_population(self, population: np.ndarray, objective_func: Callable[[np.ndarray], float]) -> np.ndarray:
        """
        è¯„ä¼°ç§ç¾¤é€‚åº”åº¦

        å‚æ•°:
            population: ç§ç¾¤çŸ©é˜µ
            objective_func: ç›®æ ‡å‡½æ•°

        è¿”å›:
            é€‚åº”åº¦æ•°ç»„
        """
        if self.config.n_jobs == 1:
            # ä¸²è¡Œè¯„ä¼°
            fitness = np.array([objective_func(individual) for individual in population])
        else:
            # å¹¶è¡Œè¯„ä¼°
            with ThreadPoolExecutor(max_workers=self.config.n_jobs) as executor:
                fitness = np.array(list(executor.map(objective_func, population)))

        return fitness

    def tournament_selection(self, population: np.ndarray, fitness: np.ndarray) -> np.ndarray:
        """
        é”¦æ ‡èµ›é€‰æ‹©

        å‚æ•°:
            population: ç§ç¾¤çŸ©é˜µ
            fitness: é€‚åº”åº¦æ•°ç»„

        è¿”å›:
            é€‰æ‹©çš„çˆ¶ä»£ä¸ªä½“
        """
        n_individuals = len(population)
        selected_indices = []

        for _ in range(n_individuals):
            # éšæœºé€‰æ‹©å‚ä¸é”¦æ ‡èµ›çš„ä¸ªä½“
            tournament_indices = np.random.choice(
                n_individuals,
                size=self.config.tournament_size,
                replace=False
            )

            # é€‰æ‹©é”¦æ ‡èµ›ä¸­é€‚åº”åº¦æœ€å¥½çš„ä¸ªä½“
            best_idx = tournament_indices[np.argmin(fitness[tournament_indices])]
            selected_indices.append(best_idx)

        return population[selected_indices]

    def sbx_crossover(self, parent1: np.ndarray, parent2: np.ndarray, bounds: 'OptimizationBounds', eta: float = 20.0) -> Tuple[np.ndarray, np.ndarray]:
        """
        æ¨¡æ‹ŸäºŒè¿›åˆ¶äº¤å‰ (SBX)

        å‚æ•°:
            parent1, parent2: çˆ¶ä»£ä¸ªä½“
            bounds: å˜é‡è¾¹ç•Œ
            eta: åˆ†å¸ƒæŒ‡æ•°

        è¿”å›:
            ä¸¤ä¸ªå­ä»£ä¸ªä½“
        """
        if np.random.random() > self.config.crossover_rate:
            return parent1.copy(), parent2.copy()

        child1, child2 = parent1.copy(), parent2.copy()

        for i in range(len(parent1)):
            if np.random.random() <= 0.5:
                if abs(parent1[i] - parent2[i]) > 1e-14:
                    if parent1[i] < parent2[i]:
                        y1, y2 = parent1[i], parent2[i]
                    else:
                        y1, y2 = parent2[i], parent1[i]

                    yl, yu = bounds.lower[i], bounds.upper[i]

                    # è®¡ç®—betaå€¼
                    beta1 = 1.0 + (2.0 * (y1 - yl) / (y2 - y1))
                    beta2 = 1.0 + (2.0 * (yu - y2) / (y2 - y1))

                    alpha1 = 2.0 - beta1**(-(eta + 1.0))
                    alpha2 = 2.0 - beta2**(-(eta + 1.0))

                    u1, u2 = np.random.random(), np.random.random()

                    if u1 <= (1.0 / alpha1):
                        betaq1 = (u1 * alpha1)**(1.0 / (eta + 1.0))
                    else:
                        betaq1 = (1.0 / (2.0 - u1 * alpha1))**(1.0 / (eta + 1.0))

                    if u2 <= (1.0 / alpha2):
                        betaq2 = (u2 * alpha2)**(1.0 / (eta + 1.0))
                    else:
                        betaq2 = (1.0 / (2.0 - u2 * alpha2))**(1.0 / (eta + 1.0))

                    child1[i] = 0.5 * ((y1 + y2) - betaq1 * (y2 - y1))
                    child2[i] = 0.5 * ((y1 + y2) + betaq2 * (y2 - y1))

        # è¾¹ç•Œä¿®å¤
        child1 = np.clip(child1, bounds.lower, bounds.upper)
        child2 = np.clip(child2, bounds.lower, bounds.upper)

        return child1, child2

    def polynomial_mutation(self, individual: np.ndarray, bounds: 'OptimizationBounds', eta: float = 20.0) -> np.ndarray:
        """
        å¤šé¡¹å¼å˜å¼‚

        å‚æ•°:
            individual: ä¸ªä½“
            bounds: å˜é‡è¾¹ç•Œ
            eta: åˆ†å¸ƒæŒ‡æ•°

        è¿”å›:
            å˜å¼‚åçš„ä¸ªä½“
        """
        mutated = individual.copy()

        for i in range(len(individual)):
            if np.random.random() <= self.config.mutation_rate:
                y = individual[i]
                yl, yu = bounds.lower[i], bounds.upper[i]

                delta1 = (y - yl) / (yu - yl)
                delta2 = (yu - y) / (yu - yl)

                u = np.random.random()

                if u <= 0.5:
                    xy = 1.0 - delta1
                    val = 2.0 * u + (1.0 - 2.0 * u) * (xy**(eta + 1.0))
                    deltaq = val**(1.0 / (eta + 1.0)) - 1.0
                else:
                    xy = 1.0 - delta2
                    val = 2.0 * (1.0 - u) + 2.0 * (u - 0.5) * (xy**(eta + 1.0))
                    deltaq = 1.0 - val**(1.0 / (eta + 1.0))

                mutated[i] = y + deltaq * (yu - yl)

                # è¾¹ç•Œä¿®å¤
                mutated[i] = np.clip(mutated[i], yl, yu)

        return mutated

    def calculate_diversity(self, population: np.ndarray) -> float:
        """
        è®¡ç®—ç§ç¾¤å¤šæ ·æ€§ï¼ˆå¹³å‡æ¬§å‡ é‡Œå¾—è·ç¦»ï¼‰

        å‚æ•°:
            population: ç§ç¾¤çŸ©é˜µ

        è¿”å›:
            ç§ç¾¤å¤šæ ·æ€§æŒ‡æ ‡
        """
        n_individuals = len(population)
        total_distance = 0.0
        count = 0

        for i in range(n_individuals):
            for j in range(i + 1, n_individuals):
                distance = np.linalg.norm(population[i] - population[j])
                total_distance += distance
                count += 1

        return total_distance / count if count > 0 else 0.0

    def optimize(
        self,
        objective_func: Callable[[np.ndarray], float],
        bounds: 'OptimizationBounds'
    ) -> Dict[str, Any]:
        """
        æ‰§è¡Œé—ä¼ ç®—æ³•ä¼˜åŒ–

        å‚æ•°:
            objective_func: ç›®æ ‡å‡½æ•°ï¼ˆæœ€å°åŒ–ï¼‰
            bounds: å†³ç­–å˜é‡è¾¹ç•Œ

        è¿”å›:
            ä¼˜åŒ–ç»“æœå­—å…¸
        """
        start_time = time.time()
        logger.info(f"å¼€å§‹é—ä¼ ç®—æ³•ä¼˜åŒ–ï¼Œç§ç¾¤å¤§å°: {self.config.population_size}, æœ€å¤§ä»£æ•°: {self.config.generations}")

        # åˆå§‹åŒ–ç§ç¾¤
        population = self.initialize_population(bounds)

        # è¯„ä¼°åˆå§‹ç§ç¾¤
        fitness = self.evaluate_population(population, objective_func)

        # è®°å½•å†å²
        self.best_fitness_history = []
        self.diversity_history = []

        best_individual = population[np.argmin(fitness)].copy()
        best_fitness = np.min(fitness)
        stagnation_count = 0

        for generation in range(self.config.generations):
            self.generation = generation

            # è®°å½•å†å²
            self.best_fitness_history.append(best_fitness)
            diversity = self.calculate_diversity(population)
            self.diversity_history.append(diversity)

            logger.info(f"ç¬¬ {generation + 1} ä»£ï¼šæœ€ä¼˜é€‚åº”åº¦ = {best_fitness:.6f}, ç§ç¾¤å¤šæ ·æ€§ = {diversity:.6f}")

            # æ—©åœæ£€æŸ¥
            if generation > 0:
                improvement = self.best_fitness_history[-2] - self.best_fitness_history[-1]
                if improvement < self.config.early_stopping_threshold:
                    stagnation_count += 1
                else:
                    stagnation_count = 0

                if stagnation_count >= self.config.early_stopping_patience:
                    logger.info(f"è§¦å‘æ—©åœæœºåˆ¶ï¼Œè¿ç»­ {stagnation_count} ä»£æ— æ˜æ˜¾æ”¹è¿›")
                    break

            # é€‰æ‹©
            selected_population = self.tournament_selection(population, fitness)

            # äº¤å‰å’Œå˜å¼‚ç”Ÿæˆæ–°ç§ç¾¤
            new_population = []

            for i in range(0, self.config.population_size, 2):
                parent1 = selected_population[i]
                parent2 = selected_population[(i + 1) % self.config.population_size]

                # äº¤å‰
                child1, child2 = self.sbx_crossover(parent1, parent2, bounds)

                # å˜å¼‚
                child1 = self.polynomial_mutation(child1, bounds)
                child2 = self.polynomial_mutation(child2, bounds)

                new_population.extend([child1, child2])

            new_population = np.array(new_population[:self.config.population_size])

            # è¯„ä¼°æ–°ç§ç¾¤
            new_fitness = self.evaluate_population(new_population, objective_func)

            # ç²¾è‹±ç­–ç•¥ï¼šä¿ç•™æœ€ä¼˜ä¸ªä½“
            combined_population = np.vstack([population, new_population])
            combined_fitness = np.hstack([fitness, new_fitness])

            # æŒ‰é€‚åº”åº¦æ’åº
            sorted_indices = np.argsort(combined_fitness)

            # é€‰æ‹©æœ€ä¼˜çš„ä¸ªä½“ç»„æˆä¸‹ä¸€ä»£
            population = combined_population[sorted_indices[:self.config.population_size]]
            fitness = combined_fitness[sorted_indices[:self.config.population_size]]

            # æ›´æ–°æœ€ä¼˜è§£
            current_best = population[0]
            current_best_fitness = fitness[0]

            if current_best_fitness < best_fitness:
                best_individual = current_best.copy()
                best_fitness = current_best_fitness

        execution_time = time.time() - start_time

        logger.info(f"é—ä¼ ç®—æ³•ä¼˜åŒ–å®Œæˆï¼Œæœ€ç»ˆæœ€ä¼˜é€‚åº”åº¦: {best_fitness:.6f}, è€—æ—¶: {execution_time:.2f}ç§’")

        return {
            "best_solution": best_individual,
            "best_fitness": best_fitness,
            "n_generations": generation + 1,
            "execution_time": execution_time,
            "fitness_history": self.best_fitness_history,
            "diversity_history": self.diversity_history,
            "final_population": population,
            "convergence_info": {
                "early_stopped": stagnation_count >= self.config.early_stopping_patience,
                "stagnation_generations": stagnation_count
            }
        }


# ä½¿ç”¨ç¤ºä¾‹
def rastrigin_function(x: np.ndarray) -> float:
    """Rastriginå‡½æ•°ï¼ˆæµ‹è¯•ç”¨å¤šå³°å‡½æ•°ï¼‰"""
    A = 10
    n = len(x)
    return A * n + sum(xi**2 - A * np.cos(2 * np.pi * xi) for xi in x)


# æœ€å°å¯è¿è¡Œç¤ºä¾‹
if __name__ == "__main__":
    logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

    # å®šä¹‰ä¼˜åŒ–è¾¹ç•Œ
    bounds = OptimizationBounds(
        lower=[-5.12, -5.12],
        upper=[5.12, 5.12]
    )

    # é…ç½®é—ä¼ ç®—æ³•
    config = GAConfig(
        population_size=30,
        generations=50,
        crossover_rate=0.8,
        mutation_rate=0.1,
        elitism=2,
        random_seed=42
    )

    # è¿è¡Œä¼˜åŒ–
    optimizer = GeneticAlgorithmOptimizer(config)
    result = optimizer.optimize(rastrigin_function, bounds)

    logger.info(f"æœ€ä¼˜è§£: {result['best_solution']}")
    logger.info(f"æœ€ä¼˜å€¼: {result['best_fitness']:.6f}")
    logger.info(f"æ”¶æ•›ä»£æ•°: {result['n_generations']}")

    # ç»˜åˆ¶æ”¶æ•›æ›²çº¿ï¼ˆå¯é€‰ï¼‰
    plt.figure(figsize=(12, 4))

    plt.subplot(1, 2, 1)
    plt.plot(result['fitness_history'])
    plt.title('é€‚åº”åº¦æ”¶æ•›æ›²çº¿')
    plt.xlabel('ä»£æ•°')
    plt.ylabel('æœ€ä¼˜é€‚åº”åº¦')
    plt.grid(True)

    plt.subplot(1, 2, 2)
    plt.plot(result['diversity_history'])
    plt.title('ç§ç¾¤å¤šæ ·æ€§å˜åŒ–')
    plt.xlabel('ä»£æ•°')
    plt.ylabel('å¤šæ ·æ€§æŒ‡æ ‡')
    plt.grid(True)

    plt.tight_layout()
    plt.show()
```

### 10.2 ç²’å­ç¾¤ä¼˜åŒ–ç®—æ³•å®ç°

```python
"""
ç²’å­ç¾¤ä¼˜åŒ–ç®—æ³•
é€‚ç”¨äºè¿ç»­å˜é‡ä¼˜åŒ–é—®é¢˜ï¼Œå…·æœ‰è‰¯å¥½çš„æ”¶æ•›ç‰¹æ€§
"""
import numpy as np
import logging
from typing import Dict, Any, Optional, Callable, List
from dataclasses import dataclass
import time
import matplotlib.pyplot as plt

logger = logging.getLogger(__name__)

@dataclass
class PSOConfig:
    """ç²’å­ç¾¤ä¼˜åŒ–ç®—æ³•é…ç½®"""
    swarm_size: int = 30
    max_iterations: int = 100
    inertia_w: float = 0.9
    inertia_w_min: float = 0.4
    c1: float = 2.0  # è®¤çŸ¥æƒé‡
    c2: float = 2.0  # ç¤¾ä¼šæƒé‡
    v_max_ratio: float = 0.2  # æœ€å¤§é€Ÿåº¦å å˜é‡èŒƒå›´çš„æ¯”ä¾‹
    early_stopping_patience: int = 15
    early_stopping_threshold: float = 1e-6
    adaptive_inertia: bool = True
    random_seed: Optional[int] = None

class ParticleSwarmOptimizer:
    """
    ç²’å­ç¾¤ä¼˜åŒ–ç®—æ³•

    åŸºäºç¾¤ä½“æ™ºèƒ½çš„ä¼˜åŒ–ç®—æ³•ï¼Œé€šè¿‡ç²’å­é—´çš„ä¿¡æ¯å…±äº«å¯»æ‰¾æœ€ä¼˜è§£
    """

    def __init__(self, config: PSOConfig):
        """
        åˆå§‹åŒ–ç²’å­ç¾¤ä¼˜åŒ–å™¨

        å‚æ•°:
            config: ç®—æ³•é…ç½®å‚æ•°
        """
        self.config = config
        self.best_fitness_history: List[float] = []
        self.iteration = 0

        if config.random_seed is not None:
            np.random.seed(config.random_seed)

    def initialize_swarm(self, bounds: 'OptimizationBounds') -> Dict[str, np.ndarray]:
        """
        åˆå§‹åŒ–ç²’å­ç¾¤

        å‚æ•°:
            bounds: å†³ç­–å˜é‡è¾¹ç•Œ

        è¿”å›:
            åŒ…å«ä½ç½®å’Œé€Ÿåº¦çš„å­—å…¸
        """
        n_vars = len(bounds.lower)

        # åˆå§‹åŒ–ä½ç½®
        positions = np.random.uniform(
            low=bounds.lower,
            high=bounds.upper,
            size=(self.config.swarm_size, n_vars)
        )

        # è®¡ç®—æœ€å¤§é€Ÿåº¦
        v_max = self.config.v_max_ratio * (np.array(bounds.upper) - np.array(bounds.lower))

        # åˆå§‹åŒ–é€Ÿåº¦
        velocities = np.random.uniform(
            low=-v_max,
            high=v_max,
            size=(self.config.swarm_size, n_vars)
        )

        logger.info(f"åˆå§‹åŒ–ç²’å­ç¾¤å®Œæˆï¼Œç²’å­æ•°: {self.config.swarm_size}, å˜é‡ç»´åº¦: {n_vars}")

        return {
            "positions": positions,
            "velocities": velocities,
            "v_max": v_max
        }

    def update_inertia_weight(self, iteration: int) -> float:
        """
        æ›´æ–°æƒ¯æ€§æƒé‡ï¼ˆçº¿æ€§é€’å‡ï¼‰

        å‚æ•°:
            iteration: å½“å‰è¿­ä»£æ¬¡æ•°

        è¿”å›:
            å½“å‰æƒ¯æ€§æƒé‡
        """
        if self.config.adaptive_inertia:
            return self.config.inertia_w_min + (self.config.inertia_w - self.config.inertia_w_min) * \
                   (self.config.max_iterations - iteration) / self.config.max_iterations
        else:
            return self.config.inertia_w

    def update_velocity(
        self,
        velocities: np.ndarray,
        positions: np.ndarray,
        personal_best: np.ndarray,
        global_best: np.ndarray,
        v_max: np.ndarray,
        w: float
    ) -> np.ndarray:
        """
        æ›´æ–°ç²’å­é€Ÿåº¦

        å‚æ•°:
            velocities: å½“å‰é€Ÿåº¦
            positions: å½“å‰ä½ç½®
            personal_best: ä¸ªä½“æœ€ä¼˜ä½ç½®
            global_best: å…¨å±€æœ€ä¼˜ä½ç½®
            v_max: æœ€å¤§é€Ÿåº¦é™åˆ¶
            w: æƒ¯æ€§æƒé‡

        è¿”å›:
            æ›´æ–°åçš„é€Ÿåº¦
        """
        r1 = np.random.random(velocities.shape)
        r2 = np.random.random(velocities.shape)

        # PSOé€Ÿåº¦æ›´æ–°å…¬å¼
        new_velocities = (
            w * velocities +
            self.config.c1 * r1 * (personal_best - positions) +
            self.config.c2 * r2 * (global_best - positions)
        )

        # é€Ÿåº¦é™åˆ¶
        new_velocities = np.clip(new_velocities, -v_max, v_max)

        return new_velocities

    def update_position(
        self,
        positions: np.ndarray,
        velocities: np.ndarray,
        bounds: 'OptimizationBounds'
    ) -> np.ndarray:
        """
        æ›´æ–°ç²’å­ä½ç½®

        å‚æ•°:
            positions: å½“å‰ä½ç½®
            velocities: å½“å‰é€Ÿåº¦
            bounds: å˜é‡è¾¹ç•Œ

        è¿”å›:
            æ›´æ–°åçš„ä½ç½®
        """
        new_positions = positions + velocities

        # è¾¹ç•Œå¤„ç†
        new_positions = np.clip(new_positions, bounds.lower, bounds.upper)

        return new_positions

    def optimize(
        self,
        objective_func: Callable[[np.ndarray], float],
        bounds: 'OptimizationBounds'
    ) -> Dict[str, Any]:
        """
        æ‰§è¡Œç²’å­ç¾¤ä¼˜åŒ–

        å‚æ•°:
            objective_func: ç›®æ ‡å‡½æ•°ï¼ˆæœ€å°åŒ–ï¼‰
            bounds: å†³ç­–å˜é‡è¾¹ç•Œ

        è¿”å›:
            ä¼˜åŒ–ç»“æœå­—å…¸
        """
        start_time = time.time()
        logger.info(f"å¼€å§‹ç²’å­ç¾¤ä¼˜åŒ–ï¼Œç²’å­æ•°: {self.config.swarm_size}, æœ€å¤§è¿­ä»£: {self.config.max_iterations}")

        # åˆå§‹åŒ–ç²’å­ç¾¤
        swarm = self.initialize_swarm(bounds)
        positions = swarm["positions"]
        velocities = swarm["velocities"]
        v_max = swarm["v_max"]

        # è¯„ä¼°åˆå§‹é€‚åº”åº¦
        fitness = np.array([objective_func(pos) for pos in positions])

        # åˆå§‹åŒ–ä¸ªä½“æœ€ä¼˜å’Œå…¨å±€æœ€ä¼˜
        personal_best_positions = positions.copy()
        personal_best_fitness = fitness.copy()

        global_best_idx = np.argmin(fitness)
        global_best_position = positions[global_best_idx].copy()
        global_best_fitness = fitness[global_best_idx]

        # è®°å½•å†å²
        self.best_fitness_history = []
        stagnation_count = 0

        for iteration in range(self.config.max_iterations):
            self.iteration = iteration

            # è®°å½•å†å²
            self.best_fitness_history.append(global_best_fitness)

            logger.info(f"ç¬¬ {iteration + 1} æ¬¡è¿­ä»£ï¼šå…¨å±€æœ€ä¼˜é€‚åº”åº¦ = {global_best_fitness:.6f}")

            # æ—©åœæ£€æŸ¥
            if iteration > 0:
                improvement = self.best_fitness_history[-2] - self.best_fitness_history[-1]
                if improvement < self.config.early_stopping_threshold:
                    stagnation_count += 1
                else:
                    stagnation_count = 0

                if stagnation_count >= self.config.early_stopping_patience:
                    logger.info(f"è§¦å‘æ—©åœæœºåˆ¶ï¼Œè¿ç»­ {stagnation_count} æ¬¡è¿­ä»£æ— æ˜æ˜¾æ”¹è¿›")
                    break

            # æ›´æ–°æƒ¯æ€§æƒé‡
            w = self.update_inertia_weight(iteration)

            # æ›´æ–°é€Ÿåº¦
            velocities = self.update_velocity(
                velocities, positions, personal_best_positions,
                global_best_position, v_max, w
            )

            # æ›´æ–°ä½ç½®
            positions = self.update_position(positions, velocities, bounds)

            # è¯„ä¼°æ–°ä½ç½®
            fitness = np.array([objective_func(pos) for pos in positions])

            # æ›´æ–°ä¸ªä½“æœ€ä¼˜
            improved_mask = fitness < personal_best_fitness
            personal_best_positions[improved_mask] = positions[improved_mask]
            personal_best_fitness[improved_mask] = fitness[improved_mask]

            # æ›´æ–°å…¨å±€æœ€ä¼˜
            best_idx = np.argmin(personal_best_fitness)
            if personal_best_fitness[best_idx] < global_best_fitness:
                global_best_position = personal_best_positions[best_idx].copy()
                global_best_fitness = personal_best_fitness[best_idx]

        execution_time = time.time() - start_time

        logger.info(f"ç²’å­ç¾¤ä¼˜åŒ–å®Œæˆï¼Œæœ€ç»ˆæœ€ä¼˜é€‚åº”åº¦: {global_best_fitness:.6f}, è€—æ—¶: {execution_time:.2f}ç§’")

        return {
            "best_solution": global_best_position,
            "best_fitness": global_best_fitness,
            "n_iterations": iteration + 1,
            "execution_time": execution_time,
            "fitness_history": self.best_fitness_history,
            "final_positions": positions,
            "convergence_info": {
                "early_stopped": stagnation_count >= self.config.early_stopping_patience,
                "stagnation_iterations": stagnation_count
            }
        }


# æœ€å°å¯è¿è¡Œç¤ºä¾‹
if __name__ == "__main__":
    logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

    def sphere_function(x: np.ndarray) -> float:
        """Sphereå‡½æ•°ï¼ˆç®€å•æµ‹è¯•å‡½æ•°ï¼‰"""
        return sum(xi**2 for xi in x)

    # å®šä¹‰ä¼˜åŒ–è¾¹ç•Œ
    bounds = OptimizationBounds(
        lower=[-10.0, -10.0],
        upper=[10.0, 10.0]
    )

    # é…ç½®ç²’å­ç¾¤ç®—æ³•
    config = PSOConfig(
        swarm_size=20,
        max_iterations=50,
        inertia_w=0.9,
        inertia_w_min=0.4,
        c1=2.0,
        c2=2.0,
        random_seed=42
    )

    # è¿è¡Œä¼˜åŒ–
    optimizer = ParticleSwarmOptimizer(config)
    result = optimizer.optimize(sphere_function, bounds)

    logger.info(f"æœ€ä¼˜è§£: {result['best_solution']}")
    logger.info(f"æœ€ä¼˜å€¼: {result['best_fitness']:.6f}")
    logger.info(f"æ”¶æ•›è¿­ä»£: {result['n_iterations']}")

    # ç»˜åˆ¶æ”¶æ•›æ›²çº¿ï¼ˆå¯é€‰ï¼‰
    plt.figure(figsize=(8, 6))
    plt.plot(result['fitness_history'], marker='o', linewidth=2)
    plt.title('ç²’å­ç¾¤ä¼˜åŒ–æ”¶æ•›æ›²çº¿')
    plt.xlabel('è¿­ä»£æ¬¡æ•°')
    plt.ylabel('å…¨å±€æœ€ä¼˜é€‚åº”åº¦')
    plt.grid(True, alpha=0.3)
    plt.yscale('log')
    plt.show()
```

### 10.3 æ°´æ³µç³»ç»Ÿä¼˜åŒ–å…·ä½“åº”ç”¨ç¤ºä¾‹

```python
"""
æ°´æ³µç³»ç»Ÿä¼˜åŒ–å…·ä½“åº”ç”¨
ç»“åˆå®é™…å·¥ç¨‹å‚æ•°è¿›è¡Œå¤šç›®æ ‡ä¼˜åŒ–
"""
import numpy as np
from typing import Dict, Any, Tuple, List
from dataclasses import dataclass
import logging

logger = logging.getLogger(__name__)

@dataclass
class PumpSystemConfig:
    """æ°´æ³µç³»ç»Ÿé…ç½®"""
    n_pumps: int = 3  # æ³µå°æ•°
    rated_flow: float = 100.0  # é¢å®šæµé‡ mÂ³/h
    rated_head: float = 80.0   # é¢å®šæ‰¬ç¨‹ m
    rated_power: float = 22.0  # é¢å®šåŠŸç‡ kW
    efficiency_curve_params: Dict[str, float] | None = None  # æ•ˆç‡æ›²çº¿å‚æ•°

    def __post_init__(self):
        if self.efficiency_curve_params is None:
            # é»˜è®¤æ•ˆç‡æ›²çº¿å‚æ•°ï¼ˆäºŒæ¬¡å¤šé¡¹å¼ï¼‰
            self.efficiency_curve_params = {
                'a': -0.0001,
                'b': 0.015,
                'c': 0.2
            }

class PumpSystemOptimizer:
    """
    æ°´æ³µç³»ç»Ÿä¼˜åŒ–å™¨

    ä¼˜åŒ–ç›®æ ‡ï¼š
    1. æœ€å°åŒ–èƒ½è€—
    2. æœ€å¤§åŒ–æ•ˆç‡
    3. æœ€å°åŒ–ç£¨æŸ
    """

    def __init__(self, config: PumpSystemConfig):
        """
        åˆå§‹åŒ–æ°´æ³µç³»ç»Ÿä¼˜åŒ–å™¨

        å‚æ•°:
            config: ç³»ç»Ÿé…ç½®
        """
        self.config = config

    def calculate_pump_efficiency(self, flow_rate: float) -> float:
        """
        è®¡ç®—æ°´æ³µæ•ˆç‡

        å‚æ•°:
            flow_rate: æµé‡ (mÂ³/h)

        è¿”å›:
            æ•ˆç‡å€¼ (0-1)
        """
        params = self.config.efficiency_curve_params

        # å½’ä¸€åŒ–æµé‡
        normalized_flow = flow_rate / self.config.rated_flow

        # äºŒæ¬¡å¤šé¡¹å¼æ•ˆç‡æ›²çº¿
        efficiency = (
            params['a'] * normalized_flow**2 +
            params['b'] * normalized_flow +
            params['c']
        )

        # é™åˆ¶æ•ˆç‡èŒƒå›´
        return float(np.clip(efficiency, 0.1, 0.95))

    def calculate_pump_head(self, flow_rate: float) -> float:
        """
        è®¡ç®—æ°´æ³µæ‰¬ç¨‹

        å‚æ•°:
            flow_rate: æµé‡ (mÂ³/h)

        è¿”å›:
            æ‰¬ç¨‹ (m)
        """
        # ç®€åŒ–çš„æ‰¬ç¨‹-æµé‡ç‰¹æ€§æ›²çº¿
        normalized_flow = flow_rate / self.config.rated_flow

        # äºŒæ¬¡å¤šé¡¹å¼æ‰¬ç¨‹æ›²çº¿
        head = self.config.rated_head * (
            1.2 - 0.8 * normalized_flow - 0.4 * normalized_flow**2
        )

        return float(max(head, 0.0))

    def calculate_pump_power(self, flow_rate: float, head: float, efficiency: float) -> float:
        """
        è®¡ç®—æ°´æ³µåŠŸç‡

        å‚æ•°:
            flow_rate: æµé‡ (mÂ³/h)
            head: æ‰¬ç¨‹ (m)
            efficiency: æ•ˆç‡

        è¿”å›:
            åŠŸç‡ (kW)
        """
        # æ°´çš„å¯†åº¦ (kg/mÂ³)
        rho_water = 1000.0
        # é‡åŠ›åŠ é€Ÿåº¦ (m/sÂ²)
        g = 9.81

        # æµé‡è½¬æ¢ (mÂ³/h -> mÂ³/s)
        flow_rate_ms = flow_rate / 3600.0

        # ç†è®ºåŠŸç‡ (kW)
        theoretical_power = (rho_water * g * flow_rate_ms * head) / 1000.0

        # è€ƒè™‘æ•ˆç‡çš„å®é™…åŠŸç‡
        if efficiency > 0:
            actual_power = theoretical_power / efficiency
        else:
            actual_power = float('inf')

        return float(actual_power)

    def pump_system_objectives(self, decision_vars: np.ndarray) -> Dict[str, float]:
        """
        æ°´æ³µç³»ç»Ÿå¤šç›®æ ‡å‡½æ•°

        å‚æ•°:
            decision_vars: å†³ç­–å˜é‡ [pump1_flow, pump2_flow, pump3_flow, pump1_freq, pump2_freq, pump3_freq]

        è¿”å›:
            å¤šç›®æ ‡å€¼å­—å…¸
        """
        n_pumps = self.config.n_pumps

        # æå–å†³ç­–å˜é‡
        flow_rates = decision_vars[:n_pumps]  # æ¯å°æ³µçš„æµé‡
        frequencies = decision_vars[n_pumps:]  # æ¯å°æ³µçš„é¢‘ç‡

        total_power = 0.0
        total_efficiency_flow = 0.0
        total_flow = 0.0
        total_wear = 0.0

        for i in range(n_pumps):
            if flow_rates[i] > 0:  # æ³µè¿è¡Œ
                # è€ƒè™‘é¢‘ç‡å¯¹æ€§èƒ½çš„å½±å“
                freq_ratio = frequencies[i] / 50.0  # é¢å®šé¢‘ç‡50Hz

                # è°ƒæ•´æµé‡å’Œæ‰¬ç¨‹
                adjusted_flow = flow_rates[i] * freq_ratio
                adjusted_head = self.calculate_pump_head(adjusted_flow) * (freq_ratio**2)

                # è®¡ç®—æ•ˆç‡å’ŒåŠŸç‡
                efficiency = self.calculate_pump_efficiency(adjusted_flow)
                power = self.calculate_pump_power(adjusted_flow, adjusted_head, efficiency)

                # è€ƒè™‘é¢‘ç‡å¯¹åŠŸç‡çš„å½±å“
                power *= freq_ratio**3

                # ç´¯åŠ æŒ‡æ ‡
                total_power += power
                total_efficiency_flow += efficiency * adjusted_flow
                total_flow += adjusted_flow

                # ç®€åŒ–çš„ç£¨æŸæ¨¡å‹ï¼ˆåç¦»æœ€ä¼˜å·¥ä½œç‚¹çš„æƒ©ç½šï¼‰
                optimal_flow_ratio = 0.7  # æœ€ä¼˜æµé‡æ¯”ä¾‹
                flow_deviation = abs(adjusted_flow / self.config.rated_flow - optimal_flow_ratio)
                wear_factor = 1.0 + 2.0 * flow_deviation**2
                total_wear += wear_factor

        # è®¡ç®—ç›®æ ‡å‡½æ•°
        # 1. èƒ½è€—ç›®æ ‡ï¼ˆæœ€å°åŒ–ï¼‰
        energy_objective = total_power

        # 2. æ•ˆç‡ç›®æ ‡ï¼ˆæœ€å¤§åŒ–ï¼Œè½¬ä¸ºæœ€å°åŒ–ï¼‰
        if total_flow > 0:
            weighted_efficiency = total_efficiency_flow / total_flow
            efficiency_objective = -weighted_efficiency  # è´Ÿå·è¡¨ç¤ºæœ€å¤§åŒ–è½¬æœ€å°åŒ–
        else:
            efficiency_objective = 1.0  # æƒ©ç½šæ— æµé‡æƒ…å†µ

        # 3. ç£¨æŸç›®æ ‡ï¼ˆæœ€å°åŒ–ï¼‰
        wear_objective = total_wear

        return {
            "energy": float(energy_objective),
            "efficiency": float(efficiency_objective),
            "wear": float(wear_objective),
            "total_flow": float(total_flow),
            "total_power": float(total_power)
        }

    def pump_system_constraints(self, decision_vars: np.ndarray) -> Dict[str, bool]:
        """
        æ°´æ³µç³»ç»Ÿçº¦æŸæ¡ä»¶

        å‚æ•°:
            decision_vars: å†³ç­–å˜é‡

        è¿”å›:
            çº¦æŸæ»¡è¶³æƒ…å†µå­—å…¸
        """
        n_pumps = self.config.n_pumps
        flow_rates = decision_vars[:n_pumps]
        frequencies = decision_vars[n_pumps:]

        constraints: Dict[str, bool] = {}

        # 1. æµé‡éœ€æ±‚çº¦æŸ
        total_flow = float(sum(flow_rates))
        flow_demand = 200.0  # ç›®æ ‡æµé‡ mÂ³/h
        flow_tolerance = 0.05  # 5% å®¹å·®

        constraints["flow_demand"] = abs(total_flow - flow_demand) / flow_demand <= flow_tolerance

        # 2. å‹åŠ›çº¦æŸ
        min_head_required = 60.0  # æœ€å°æ‰¬ç¨‹è¦æ±‚ m

        for i, flow_rate in enumerate(flow_rates):
            if flow_rate > 0:
                freq_ratio = frequencies[i] / 50.0
                adjusted_flow = flow_rate * freq_ratio
                head = self.calculate_pump_head(adjusted_flow) * (freq_ratio**2)
                constraints[f"pump_{i}_head"] = head >= min_head_required
            else:
                constraints[f"pump_{i}_head"] = True

        # 3. åŠŸç‡çº¦æŸ
        max_power_per_pump = self.config.rated_power * 1.1  # å…è®¸10%è¶…è½½

        for i, flow_rate in enumerate(flow_rates):
            if flow_rate > 0:
                freq_ratio = frequencies[i] / 50.0
                adjusted_flow = flow_rate * freq_ratio
                adjusted_head = self.calculate_pump_head(adjusted_flow) * (freq_ratio**2)
                efficiency = self.calculate_pump_efficiency(adjusted_flow)
                power = self.calculate_pump_power(adjusted_flow, adjusted_head, efficiency) * (freq_ratio**3)

                constraints[f"pump_{i}_power"] = power <= max_power_per_pump
            else:
                constraints[f"pump_{i}_power"] = True

        # 4. è¿è¡Œå°æ•°çº¦æŸï¼ˆè‡³å°‘ä¸€å°è¿è¡Œï¼‰
        running_pumps = sum(1 for flow in flow_rates if flow > 0)
        constraints["min_running_pumps"] = running_pumps >= 1

        return constraints


# ç»¼åˆä¼˜åŒ–ç¤ºä¾‹
def pump_optimization_example():
    """æ°´æ³µç³»ç»Ÿä¼˜åŒ–å®Œæ•´ç¤ºä¾‹"""
    logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

    # ç³»ç»Ÿé…ç½®
    config = PumpSystemConfig(
        n_pumps=3,
        rated_flow=100.0,
        rated_head=80.0,
        rated_power=22.0
    )

    # åˆ›å»ºä¼˜åŒ–å™¨
    pump_optimizer = PumpSystemOptimizer(config)

    # å®šä¹‰ä¼˜åŒ–è¾¹ç•Œ
    # å˜é‡ï¼š[pump1_flow, pump2_flow, pump3_flow, pump1_freq, pump2_freq, pump3_freq]
    bounds = OptimizationBounds(
        lower=[0.0, 0.0, 0.0, 30.0, 30.0, 30.0],  # æµé‡ >= 0, é¢‘ç‡ >= 30Hz
        upper=[120.0, 120.0, 120.0, 50.0, 50.0, 50.0]  # æµé‡ <= 120 mÂ³/h, é¢‘ç‡ <= 50Hz
    )

    # å®šä¹‰çº¦æŸä¼˜åŒ–ç›®æ ‡å‡½æ•°
    def constrained_objective(x: np.ndarray) -> float:
        """å¸¦çº¦æŸçš„ç›®æ ‡å‡½æ•°"""
        objectives = pump_optimizer.pump_system_objectives(x)
        constraints = pump_optimizer.pump_system_constraints(x)

        # å¤šç›®æ ‡åŠ æƒç»„åˆ
        energy_weight = 0.4
        efficiency_weight = 0.3
        wear_weight = 0.3

        objective_value = (
            energy_weight * objectives["energy"] +
            efficiency_weight * objectives["efficiency"] +
            wear_weight * objectives["wear"]
        )

        # çº¦æŸè¿åæƒ©ç½š
        penalty = 0.0
        for satisfied in constraints.values():
            if not satisfied:
                penalty += 1000.0  # å¤§æƒ©ç½š

        return float(objective_value + penalty)

    # ä½¿ç”¨é—ä¼ ç®—æ³•ä¼˜åŒ–
    ga_config = GAConfig(
        population_size=40,
        generations=80,
        crossover_rate=0.8,
        mutation_rate=0.1,
        random_seed=42
    )

    ga_optimizer = GeneticAlgorithmOptimizer(ga_config)
    result = ga_optimizer.optimize(constrained_objective, bounds)

    # åˆ†æç»“æœ
    best_solution = result["best_solution"]
    n_pumps = config.n_pumps

    logger.info("=== æ°´æ³µç³»ç»Ÿä¼˜åŒ–ç»“æœ ===")
    logger.info(f"æœ€ä¼˜ç›®æ ‡å€¼: {result['best_fitness']:.4f}")
    logger.info(f"æ”¶æ•›ä»£æ•°: {result['n_generations']}")
    logger.info(f"è®¡ç®—æ—¶é—´: {result['execution_time']:.2f}ç§’")

    logger.info("--- æœ€ä¼˜è¿è¡Œå‚æ•° ---")
    for i in range(n_pumps):
        flow = best_solution[i]
        freq = best_solution[i + n_pumps]
        logger.info(f"æ°´æ³µ {i+1}: æµé‡ = {flow:.2f} mÂ³/h, é¢‘ç‡ = {freq:.1f} Hz")

    # è¯¦ç»†æ€§èƒ½åˆ†æ
    objectives = pump_optimizer.pump_system_objectives(best_solution)
    constraints = pump_optimizer.pump_system_constraints(best_solution)

    logger.info("--- æ€§èƒ½æŒ‡æ ‡ ---")
    logger.info(f"æ€»æµé‡: {objectives['total_flow']:.2f} mÂ³/h")
    logger.info(f"æ€»åŠŸç‡: {objectives['total_power']:.2f} kW")
    logger.info(f"ç³»ç»Ÿæ•ˆç‡: {-objectives['efficiency']:.3f}")
    logger.info(f"ç£¨æŸæŒ‡æ ‡: {objectives['wear']:.2f}")

    all_satisfied = all(constraints.values())
    logger.info("--- çº¦æŸæ£€æŸ¥ ---")
    for name, satisfied in constraints.items():
        status = "æ»¡è¶³" if satisfied else "è¿å"
        logger.info(f"{name}: {status}")

    if all_satisfied:
        logger.info("æ‰€æœ‰çº¦æŸå‡æ»¡è¶³ï¼")
    else:
        logger.info("å­˜åœ¨çº¦æŸè¿åï¼Œéœ€è¦è°ƒæ•´å‚æ•°ã€‚")

    return result


if __name__ == "__main__":
    pump_optimization_example()
```
