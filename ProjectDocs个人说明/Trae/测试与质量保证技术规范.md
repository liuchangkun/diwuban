# 测试与质量保证技术规范

## 🧪 如何执行测试与质量门禁

1. 同步依赖与环境：使用项目级 .venv，安装 requirements.txt；Python 3.13.6。
1. 质量检查预设：ruff lint+format → mypy/pyright → pytest（默认跳过慢测）。
1. 覆盖率门槛：全局 ≥ 70%，核心模块优先；生成 XML 报告归档。
1. 数据集准备：使用仓库提供的合成样本；固定随机种子。
1. 输出：中文日志，关键步骤记录“参数/耗时/结果/异常”。

版本：v1.0 | 适用范围：单元/集成/E2E 测试、数据与算法精度验证、性能测试、质量门禁与报告

目标：

- 将“精度验证与质量保证”等分散内容从总技术规范中拆分，降低单文件行数并强化可执行标准。
- 建立覆盖数据处理、优化算法、实时链路的端到端质量体系，确保可回归、可度量、可追溯。
- 与项目工程化基线一致：Python 3.13.6；.venv；依赖集中管理；CI 启用 lint + type + test 质量门禁。

## 1. 总体质量门槛

- 代码风格：Ruff 统一 lint + format；无高/中等级 lint 违规。
- 类型检查：mypy/pyright 必须通过；对外/关键函数均提供精确类型注解（避免 Any）。
- 单元测试覆盖率：全局行覆盖率 ≥ 70%（阈值在 CI 强制）；核心模块优先保障。
- 日志与可观测：所有自动化测试输出中文日志；关键步骤记录耗时与关键参数。

## 2. 测试分层与职责

- 单元测试（Unit）
  - 范围：纯函数/类的小粒度行为；长度 ≤ 50 行的函数优先覆盖。
  - 要求：Arrange-Act-Assert 结构清晰；随机性固定种子；隔离 I/O（使用 mock）。
  - 失败定位：断言消息包含输入参数要点与期望-实际对比。
- 组件/集成测试（Integration）
  - 范围：数据库、缓存、外部接口适配器、消息通道；覆盖协议边界与序列化/反序列化。
  - 策略：优先使用 fake/模拟服务；必要时使用临时测试环境。
- 端到端测试（E2E）
  - 范围：从数据采集 → 流式处理 → 质量监控 → 存储/优化 → 对外接口/推送的关键路径。
  - 验收：以业务指标为准（正确性、时效、幂等）。

## 3. 数据质量与 CSV 校验测试

- 读取：pandas read_csv 指定 dtype/parse_dates，禁止隐式推断；大文件分块读取用例验证内存占用上限。
- 结构校验：列名、必填列、枚举值范围、时间戳时区（统一 UTC）。
- 异常数据：缺失、极端/离群值检测与处理策略（丢弃/插补）的一致性测试。
- 幂等性：重复导入/重试不产生重复记录或污染。

## 4. 曲线拟合精度验证（数据处理模块）

- 指标：R²、RMSE、MAE 必测；基准阈值 R² ≥ 0.95（除非场景特批并说明）。
- 交叉验证：k-fold（建议 k=5 或 10）；报告折内/折外指标分布（均值、方差、P95）。
- 物理一致性：单调性/边界条件/单位转换正确性；对异常拟合输出给出判定与回退策略测试。
- 残差分析：残差均值≈0、无系统性趋势；若存在偏移需测试是否触发重拟合/告警分支。

## 5. 优化算法验证（单/多目标）

- 单目标（含贝叶斯优化）
  - 初始采样：拉丁超立方/随机覆盖度评估；边界点/可行域覆盖测试。
  - 采集函数：EI/PI/UCB 行为用例（在控场景下期望选点与改进幅度）。
  - 收敛性：标准基准函数（Sphere、Rosenbrock、Rastrigin）上绘制并断言收敛曲线趋势与最终误差阈值。
  - 复现实验：固定随机种子，结果方差不超过设定阈值（例如最佳值标准差 ≤ 5%）。
- 多目标（NSGA-II）
  - 正确性：非支配排序、拥挤距离计算的边界用例（重复点、退化前沿）。
  - 基准：ZDT1/2/3 等问题的帕累托近似前沿；超体积（Hypervolume）随代数单调上升的统计检验。
  - 选择/交叉/变异：参数化用例覆盖（交叉概率、变异率），断言多样性与收敛平衡。

## 6. 实时链路与流式计算测试

- 采集缓冲：达到容量/定时条件触发 flush 的时序一致性；并发源（Modbus/OPC UA/MQTT）互不阻塞。
- 背压：处理延迟上升时采集速率自适应降速；阈值/退避策略符合配置。
- 质量监控：质量分数计算（时间新鲜度、取值范围、变化率）与阈值告警触发的准确性；最近 N 条历史截断逻辑。
- WebSocket：订阅过滤、速率限制（每连接 ≤ N 条/秒）、心跳与断线重连的用例覆盖。

## 7. API 测试

- 输入校验：JSON schema/类型/范围/必填校验；路径使用 pathlib 白名单。

## 8. 性能与容量测试

- 目标：
  - 数据导入：≥ 100 MB/s（基准样本集）
  - 优化收敛时间：≤ 5 分钟（给定规模）
  - 数据库查询 P95：≤ 100 ms；并发用户 ≥ 100
  - 资源：CPU ≤ 70%，内存 ≤ 80%
- 方法：
  - 压测工具（可自选）对 API/实时推送/数据库进行压测；收集 P50/P95/P99 与错误率。
  - 记录系统指标（CPU/内存/磁盘/网络）并生成对比报告。

## 9. 可靠性与故障注入

- 网络抖动/超时/重连；消息重复/乱序；时钟偏移；外部依赖降级与回退路径。

## 10. CI/CD 质量门禁（建议流程）

- 步骤顺序：
  1. 同步依赖 → 2) ruff lint+format 检查 → 3) mypy/pyright 类型检查 → 4) pytest（默认跳过慢测试） → 5) 覆盖率阈值检查（≥ 70%） → 6) 制品与部署。
- 分支保护：主干禁止直接提交；PR 必须通过所有门禁并经 Code Review。
- 构件与追踪：生成 JUnit XML、Coverage XML、测试趋势图，归档到 CI 平台。

### 10.1 pytest配置文件 (pytest.ini)

```ini
[tool:pytest]
# 测试发现
testpaths = tests
python_files = test_*.py *_test.py
python_classes = Test* *Tests
python_functions = test_*

# 并行执行
addopts =
    --strict-markers
    --strict-config
    --verbose
    --tb=short
    --cov=src
    --cov-report=term-missing
    --cov-report=xml:coverage.xml
    --cov-report=html:htmlcov
    --cov-fail-under=70
    --durations=10

# 标记定义
markers =
    slow: 标记为慢测试，默认跳过
    integration: 集成测试，需要数据库连接
    e2e: 端到端测试，需要完整环境
    performance: 性能测试，需要特殊环境
    unit: 单元测试（默认）
    smoke: 冒烟测试，快速验证核心功能

# 过滤器
filterwarnings =
    ignore::UserWarning
    ignore::DeprecationWarning:pkg_resources.*
```

### 10.2 测试夹具配置 (conftest.py)

```python
"""
测试通用配置与夹具
提供数据库连接、测试数据、Mock对象等通用测试资源
"""
import pytest
import numpy as np
import pandas as pd
from typing import Dict, Any, List
import tempfile
import os
from decimal import Decimal
from datetime import datetime, timedelta


@pytest.fixture(scope="session")
def test_config() -> Dict[str, Any]:
    """测试环境配置"""
    return {
        "database_url": "sqlite:///:memory:",
        "redis_url": "redis://localhost:6379/15",  # 测试专用数据库
        "log_level": "DEBUG",
        "test_data_path": "tests/data",
        "timeout_seconds": 30
    }


@pytest.fixture
def sample_pump_data() -> pd.DataFrame:
    """
    水泵特性曲线样本数据
    包含流量、扬程、功率、效率等关键参数
    """
    np.random.seed(42)  # 固定随机种子确保可重现

    flow_rates = np.linspace(10, 100, 20)  # 流量范围 10-100 m³/h

    # 模拟真实水泵特性曲线
    heads = 120 - 0.8 * flow_rates - 0.01 * flow_rates**2  # 扬程曲线
    powers = 15 + 0.5 * flow_rates + 0.008 * flow_rates**2  # 功率曲线
    efficiencies = np.where(
        flow_rates <= 60,
        0.2 + 0.012 * flow_rates - 0.0001 * flow_rates**2,  # 上升段
        0.85 - 0.005 * (flow_rates - 60)  # 下降段
    )

    # 添加适量噪声
    heads += np.random.normal(0, 1, len(heads))
    powers += np.random.normal(0, 0.5, len(powers))
    efficiencies += np.random.normal(0, 0.02, len(efficiencies))

    # 确保效率在合理范围内
    efficiencies = np.clip(efficiencies, 0.1, 0.95)

    return pd.DataFrame({
        'flow_rate': flow_rates,
        'head': heads,
        'power': powers,
        'efficiency': efficiencies,
        'timestamp': [datetime.now() - timedelta(minutes=i) for i in range(len(flow_rates))]
    })


@pytest.fixture
def temp_csv_file(sample_pump_data: pd.DataFrame) -> str:
    """创建临时CSV文件供测试使用"""
    with tempfile.NamedTemporaryFile(mode='w', suffix='.csv', delete=False, encoding='utf-8') as f:
        sample_pump_data.to_csv(f.name, index=False)
        yield f.name

    # 清理
    if os.path.exists(f.name):
        os.unlink(f.name)


@pytest.fixture
def curve_fitting_tolerance() -> Dict[str, float]:
    """曲线拟合精度容忍度配置"""
    return {
        "r_squared_min": 0.85,  # R²最小值
        "rmse_max": 5.0,        # RMSE最大值
        "mape_max": 0.15,       # MAPE最大值 (15%)
        "prediction_tolerance": 0.1  # 预测容忍度 (10%)
    }


@pytest.fixture
def optimization_bounds() -> Dict[str, tuple]:
    """优化算法边界条件"""
    return {
        "frequency": (30.0, 50.0),  # 频率范围 Hz
        "flow_rate": (10.0, 100.0), # 流量范围 m³/h
        "pressure": (0.1, 1.0),     # 压力范围 MPa
        "efficiency": (0.3, 0.95)   # 效率范围
    }
```

### 10.3 曲线拟合测试示例

```python
"""
曲线拟合模块单元测试
测试多项式、幂函数、指数、SVR、神经网络等拟合方法
"""
import logging
import pytest
import numpy as np
from unittest.mock import Mock, patch
import pandas as pd
from typing import Dict, Any

# 配置日志
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)

# 假设这些是我们要测试的类（从技术规范文档中引用）
from src.fitting.polynomial import PolynomialFitter
from src.fitting.power import PowerFitter
from src.fitting.exponential import ExponentialFitter
from src.fitting.svr import SVRFitter


class TestPolynomialFitter:
    """多项式拟合器测试类"""

    def test_init_default_degree(self):
        """测试默认初始化"""
        fitter = PolynomialFitter()
        assert fitter.degree == 2
        assert fitter.coefficients is None
        assert fitter.r_squared == 0.0

    def test_init_custom_degree(self):
        """测试自定义阶数初始化"""
        fitter = PolynomialFitter(degree=3)
        assert fitter.degree == 3

    def test_init_invalid_degree_raises_error(self):
        """测试无效阶数抛出异常"""
        with pytest.raises(ValueError, match="多项式阶数必须为正整数"):
            PolynomialFitter(degree=0)

        with pytest.raises(ValueError, match="多项式阶数必须为正整数"):
            PolynomialFitter(degree=-1)

    def test_fit_normal_case(self, sample_pump_data: pd.DataFrame, curve_fitting_tolerance: Dict[str, float]):
        """测试正常拟合情况"""
        fitter = PolynomialFitter(degree=2)

        x = sample_pump_data['flow_rate'].values
        y = sample_pump_data['head'].values

        coefficients = fitter.fit(x, y)

        # 验证返回值
        assert coefficients is not None
        assert len(coefficients) == 3  # 二次多项式有3个系数
        assert isinstance(coefficients, dict)
        assert 'coefficients' in coefficients

        # 验证拟合质量
        assert fitter.r_squared >= curve_fitting_tolerance['r_squared_min']
        assert fitter.coefficients is not None

    def test_fit_mismatched_length_raises_error(self):
        """测试输入数据长度不匹配"""
        fitter = PolynomialFitter()
        x = np.array([1, 2, 3])
        y = np.array([4, 5])  # 长度不匹配

        with pytest.raises(ValueError, match="x和y数据长度必须相等"):
            fitter.fit(x, y)

    def test_fit_insufficient_data_raises_error(self):
        """测试数据点不足"""
        fitter = PolynomialFitter(degree=3)
        x = np.array([1, 2])  # 只有2个点，不足以拟合3次多项式
        y = np.array([4, 5])

        with pytest.raises(ValueError, match="数据点数量不足以拟合"):
            fitter.fit(x, y)

    def test_predict_before_fit_raises_error(self):
        """测试未拟合就预测抛出异常"""
        fitter = PolynomialFitter()

        with pytest.raises(RuntimeError, match="模型尚未训练"):
            fitter.predict(np.array([1, 2, 3]))

    def test_predict_after_fit(self, sample_pump_data: pd.DataFrame):
        """测试拟合后的预测功能"""
        fitter = PolynomialFitter(degree=2)

        x_train = sample_pump_data['flow_rate'].values
        y_train = sample_pump_data['head'].values

        fitter.fit(x_train, y_train)

        # 预测新点
        x_test = np.array([25.0, 50.0, 75.0])
        y_pred = fitter.predict(x_test)

        assert len(y_pred) == len(x_test)
        assert all(np.isfinite(y_pred))  # 确保预测值有效

        # 预测值应该在合理范围内（基于水泵特性）
        assert all(50 <= y <= 120 for y in y_pred)

    @pytest.mark.parametrize("degree,expected_coeffs", [
        (1, 2),  # 线性：2个系数
        (2, 3),  # 二次：3个系数
        (3, 4),  # 三次：4个系数
    ])
    def test_different_degrees(self, degree: int, expected_coeffs: int, sample_pump_data: pd.DataFrame):
        """测试不同阶数的多项式拟合"""
        fitter = PolynomialFitter(degree=degree)

        x = sample_pump_data['flow_rate'].values
        y = sample_pump_data['head'].values

        result = fitter.fit(x, y)

        assert len(result['coefficients']) == expected_coeffs
        assert fitter.r_squared > 0.0  # 应该有一定拟合效果


class TestPowerFitter:
    """幂函数拟合器测试类"""

    def test_fit_positive_values(self):
        """测试正值数据拟合"""
        fitter = PowerFitter()

        # 构造幂函数数据 y = 2 * x^0.5
        x = np.array([1, 4, 9, 16, 25, 36])
        y = 2 * np.sqrt(x)

        params = fitter.fit(x, y)

        assert 'a' in params
        assert 'b' in params

        # 验证拟合参数接近真实值
        assert abs(params['a'] - 2.0) < 0.1
        assert abs(params['b'] - 0.5) < 0.1
        assert fitter.r_squared > 0.95

    def test_fit_with_zero_or_negative_x_raises_error(self):
        """测试包含零或负值的x抛出异常"""
        fitter = PowerFitter()

        x = np.array([-1, 0, 1, 2])
        y = np.array([1, 2, 3, 4])

        with pytest.raises(ValueError, match="幂函数拟合要求x为正值"):
            fitter.fit(x, y)

    def test_fit_with_zero_or_negative_y_raises_error(self):
        """测试包含零或负值的y抛出异常"""
        fitter = PowerFitter()

        x = np.array([1, 2, 3, 4])
        y = np.array([1, -1, 3, 4])

        with pytest.raises(ValueError, match="幂函数拟合要求y为正值"):
            fitter.fit(x, y)


@pytest.mark.integration
class TestFittingIntegration:
    """拟合器集成测试"""

    def test_multiple_fitters_comparison(self, sample_pump_data: pd.DataFrame):
        """测试多种拟合器在同一数据集上的表现对比"""
        x = sample_pump_data['flow_rate'].values
        y = sample_pump_data['head'].values

        # 初始化所有拟合器
        fitters = {
            'polynomial': PolynomialFitter(degree=2),
            'power': PowerFitter(),
            'exponential': ExponentialFitter()
        }

        results = {}

        for name, fitter in fitters.items():
            try:
                if name == 'power':
                    # 确保数据为正值
                    x_pos = x[x > 0]
                    y_pos = y[:len(x_pos)]
                    y_pos = y_pos[y_pos > 0]
                    x_pos = x_pos[:len(y_pos)]

                    if len(x_pos) < 3:
                        continue

                    fitter.fit(x_pos, y_pos)
                else:
                    fitter.fit(x, y)

                results[name] = {
                    'r_squared': fitter.r_squared,
                    'fitter': fitter
                }
            except Exception as e:
                logger.error(f"{name} 拟合失败: {e}")
                continue

        # 验证至少有一种方法成功
        assert len(results) > 0

        # 验证多项式拟合通常表现较好
        if 'polynomial' in results:
            assert results['polynomial']['r_squared'] > 0.7


@pytest.mark.slow
class TestSVRFitter:
    """支持向量回归拟合器测试类"""

    def test_svr_initialization(self):
        """测试SVR初始化"""
        fitter = SVRFitter()
        assert fitter.C == 1.0
        assert fitter.epsilon == 0.1
        assert fitter.kernel == 'rbf'
        assert fitter.model is None
        assert fitter.r_squared == 0.0

    def test_svr_custom_parameters(self):
        """测试自定义SVR参数"""
        fitter = SVRFitter(C=10.0, epsilon=0.01, kernel='linear')
        assert fitter.C == 10.0
        assert fitter.epsilon == 0.01
        assert fitter.kernel == 'linear'

    def test_svr_fit_and_predict(self, sample_pump_data: pd.DataFrame):
        """测试SVR拟合和预测"""
        fitter = SVRFitter(C=1.0, epsilon=0.1)

        x = sample_pump_data['flow_rate'].values
        y = sample_pump_data['head'].values

        # 拟合模型
        result = fitter.fit(x, y)

        assert result is not None
        assert 'r_squared' in result
        assert fitter.model is not None
        assert fitter.r_squared > 0.0

        # 预测测试
        x_test = np.array([25.0, 50.0, 75.0])
        y_pred = fitter.predict(x_test)

        assert len(y_pred) == len(x_test)
        assert all(np.isfinite(y_pred))

    def test_svr_insufficient_data_raises_error(self):
        """测试SVR数据不足情况"""
        fitter = SVRFitter()
        x = np.array([1])
        y = np.array([2])

        with pytest.raises(ValueError, match="SVR拟合至少需要2个数据点"):
            fitter.fit(x, y)

    @pytest.mark.parametrize("kernel", ['linear', 'poly', 'rbf', 'sigmoid'])
    def test_svr_different_kernels(self, kernel: str):
        """测试不同核函数的SVR"""
        # 构造非线性数据
        np.random.seed(42)
        x = np.linspace(0, 10, 20)
        y = np.sin(x) + 0.1 * np.random.randn(len(x))

        fitter = SVRFitter(kernel=kernel)
        result = fitter.fit(x, y)

        assert result is not None
        assert fitter.r_squared > 0.0


class TestExponentialFitter:
    """指数函数拟合器测试类"""

    def test_exponential_initialization(self):
        """测试指数拟合器初始化"""
        fitter = ExponentialFitter()
        assert fitter.a is None
        assert fitter.b is None
        assert fitter.r_squared == 0.0

    def test_exponential_fit_positive_trend(self):
        """测试正指数趋势拟合"""
        # 构造指数数据 y = 2 * exp(0.1 * x)
        x = np.array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])
        y = 2 * np.exp(0.1 * x)

        fitter = ExponentialFitter()
        result = fitter.fit(x, y)

        assert 'a' in result
        assert 'b' in result
        assert abs(result['a'] - 2.0) < 0.5  # 容忍一定误差
        assert abs(result['b'] - 0.1) < 0.05
        assert fitter.r_squared > 0.95

    def test_exponential_fit_negative_trend(self):
        """测试负指数趋势拟合（衰减）"""
        # 构造衰减数据 y = 10 * exp(-0.2 * x)
        x = np.array([0, 1, 2, 3, 4, 5])
        y = 10 * np.exp(-0.2 * x)

        fitter = ExponentialFitter()
        result = fitter.fit(x, y)

        assert result['a'] > 0  # 幅度参数应为正
        assert result['b'] < 0  # 指数参数为负（衰减）
        assert fitter.r_squared > 0.95

    def test_exponential_with_zero_or_negative_y_raises_error(self):
        """测试包含零或负值的y抛出异常"""
        fitter = ExponentialFitter()

        x = np.array([1, 2, 3, 4])
        y = np.array([1, -1, 3, 4])  # 包含负值

        with pytest.raises(ValueError, match="指数函数拟合要求y为正值"):
            fitter.fit(x, y)

    def test_exponential_predict_after_fit(self):
        """测试指数拟合后的预测"""
        x = np.array([0, 1, 2, 3, 4])
        y = np.array([1, 2.7, 7.4, 20.1, 54.6])  # 近似 exp(x)

        fitter = ExponentialFitter()
        fitter.fit(x, y)

        # 预测新点
        x_test = np.array([5, 6])
        y_pred = fitter.predict(x_test)

        assert len(y_pred) == len(x_test)
        assert all(y > 0 for y in y_pred)  # 指数函数输出应为正


class TestNeuralNetworkFitter:
    """神经网络拟合器测试类"""

    @pytest.fixture
    def nn_config(self):
        """神经网络配置夹具"""
        return {
            'hidden_layers': [32, 16],
            'epochs': 50,  # 测试时使用较少轮次
            'learning_rate': 0.001,
            'device': 'cpu'  # 测试环境使用CPU
        }

    def test_nn_initialization(self, nn_config):
        """测试神经网络初始化"""
        fitter = NeuralNetworkFitter(**nn_config)
        assert fitter.hidden_layers == [32, 16]
        assert fitter.epochs == 50
        assert fitter.learning_rate == 0.001
        assert fitter.model is None
        assert fitter.r_squared == 0.0

    @pytest.mark.slow
    @pytest.mark.ml
    def test_nn_fit_nonlinear_data(self, nn_config):
        """测试神经网络拟合非线性数据"""
        # 构造复杂非线性数据
        np.random.seed(42)
        x = np.linspace(-2, 2, 100)
        y = x**3 - 2*x**2 + x + 1 + 0.1 * np.random.randn(len(x))

        fitter = NeuralNetworkFitter(**nn_config)
        result = fitter.fit(x, y)

        assert result is not None
        assert 'r_squared' in result
        assert 'loss_history' in result
        assert fitter.model is not None
        assert fitter.r_squared > 0.7  # 神经网络应能较好拟合非线性数据

    @pytest.mark.ml
    def test_nn_predict_after_fit(self, nn_config):
        """测试神经网络拟合后预测"""
        # 简单数据，快速测试
        x = np.array([1, 2, 3, 4, 5], dtype=np.float32)
        y = np.array([2, 4, 6, 8, 10], dtype=np.float32)  # 线性关系

        fitter = NeuralNetworkFitter(
            hidden_layers=[8],
            epochs=20,
            learning_rate=0.01,
            device='cpu'
        )
        fitter.fit(x, y)

        # 预测
        x_test = np.array([6, 7], dtype=np.float32)
        y_pred = fitter.predict(x_test)

        assert len(y_pred) == len(x_test)
        assert all(np.isfinite(y_pred))
        # 对于线性数据，预测值应接近真实值
        expected = np.array([12, 14])
        assert np.allclose(y_pred, expected, atol=2.0)  # 允许一定误差

    def test_nn_insufficient_data_raises_error(self, nn_config):
        """测试神经网络数据不足情况"""
        fitter = NeuralNetworkFitter(**nn_config)
        x = np.array([1])
        y = np.array([2])

        with pytest.raises(ValueError, match="神经网络拟合至少需要5个数据点"):
            fitter.fit(x, y)


@pytest.mark.integration
class TestDataProcessingIntegration:
    """数据处理模块集成测试"""

    def test_csv_reading_with_encoding(self, temp_csv_file: str):
        """测试CSV读取与编码处理"""
        # 测试pandas读取CSV的配置
        df = pd.read_csv(
            temp_csv_file,
            encoding='utf-8',
            dtype={
                'flow_rate': np.float64,
                'head': np.float64,
                'power': np.float64,
                'efficiency': np.float64
            },
            parse_dates=['timestamp']
        )

        assert not df.empty
        assert 'flow_rate' in df.columns
        assert 'head' in df.columns
        assert df['timestamp'].dtype.name.startswith('datetime')

        # 验证数据范围合理性
        assert df['flow_rate'].min() >= 0
        assert df['efficiency'].max() <= 1.0

    def test_data_validation_pipeline(self, sample_pump_data: pd.DataFrame):
        """测试数据验证管道"""
        # 模拟数据验证函数
        def validate_pump_data(df: pd.DataFrame) -> Dict[str, Any]:
            """水泵数据验证函数"""
            validation_results = {
                'missing_values': df.isnull().sum().to_dict(),
                'range_violations': {},
                'outliers': {},
                'is_valid': True
            }

            # 检查范围违规
            if (df['flow_rate'] < 0).any():
                validation_results['range_violations']['flow_rate'] = '存在负流量'
                validation_results['is_valid'] = False

            if (df['efficiency'] > 1.0).any():
                validation_results['range_violations']['efficiency'] = '效率超过100%'
                validation_results['is_valid'] = False

            # 检查异常值（使用3-sigma准则）
            for col in ['flow_rate', 'head', 'power']:
                mean_val = df[col].mean()
                std_val = df[col].std()
                outliers = df[(df[col] < mean_val - 3*std_val) | (df[col] > mean_val + 3*std_val)]
                if not outliers.empty:
                    validation_results['outliers'][col] = len(outliers)

            return validation_results

        # 执行验证
        results = validate_pump_data(sample_pump_data)

        assert 'missing_values' in results
        assert 'range_violations' in results
        assert 'outliers' in results
        assert 'is_valid' in results

        # 样本数据应该通过基本验证
        assert results['is_valid'] is True

    def test_interpolation_accuracy(self):
        """测试插值算法精度"""
        # 构造已知函数数据
        x_known = np.array([0, 1, 2, 3, 4, 5])
        y_known = x_known ** 2  # 二次函数

        # 插值点
        x_interp = np.array([0.5, 1.5, 2.5, 3.5, 4.5])
        y_true = x_interp ** 2  # 真实值

        # 使用样条插值
        from scipy.interpolate import interp1d
        interpolator = interp1d(x_known, y_known, kind='cubic')
        y_interp = interpolator(x_interp)

        # 验证插值精度
        max_error = np.max(np.abs(y_interp - y_true))
        assert max_error < 0.1  # 插值误差应小于0.1


@pytest.mark.slow
class TestPerformanceFitting:
    """拟合器性能测试"""

    def test_large_dataset_performance(self):
        """测试大数据集拟合性能"""
        # 生成大量数据
        np.random.seed(42)
        x = np.linspace(1, 1000, 10000)
        y = 100 - 0.5 * x + 0.001 * x**2 + np.random.normal(0, 5, len(x))

        fitter = PolynomialFitter(degree=2)

        import time
        start_time = time.time()
        fitter.fit(x, y)
        execution_time = time.time() - start_time

        # 性能要求：10K数据点拟合应在1秒内完成
        assert execution_time < 1.0
        assert fitter.r_squared > 0.8

    @pytest.mark.parametrize("dataset_size", [1000, 5000, 10000])
    def test_scalability_by_dataset_size(self, dataset_size: int):
        """测试不同数据集大小的可扩展性"""
        np.random.seed(42)
        x = np.linspace(1, 100, dataset_size)
        y = 50 - 0.3 * x + 0.001 * x**2 + np.random.normal(0, 2, len(x))

        fitter = PolynomialFitter(degree=2)

        import time
        start_time = time.time()
        fitter.fit(x, y)
        execution_time = time.time() - start_time

        # 性能要求：执行时间应与数据量呈线性关系
        time_per_point = execution_time / dataset_size
        assert time_per_point < 0.0001  # 每个数据点处理时间应小于0.1ms

    @pytest.mark.ml
    def test_memory_usage_large_datasets(self):
        """测试大数据集内存使用"""
        import psutil
        import os

        # 获取初始内存使用
        process = psutil.Process(os.getpid())
        initial_memory = process.memory_info().rss / 1024 / 1024  # MB

        # 生成大数据集
        np.random.seed(42)
        x = np.linspace(1, 1000, 50000)  # 5万个数据点
        y = 100 - 0.5 * x + 0.001 * x**2 + np.random.normal(0, 5, len(x))

        fitter = PolynomialFitter(degree=3)
        fitter.fit(x, y)

        # 获取拟合后内存使用
        final_memory = process.memory_info().rss / 1024 / 1024  # MB
        memory_increase = final_memory - initial_memory

        # 内存增长应在合理范围内（小于100MB）
        assert memory_increase < 100
```

## 11. 报告与缺陷管理

- 报告：每次流水线生成测试报告与趋势；关键指标（失败率、重试次数、平均/最大耗时）。
- 缺陷：按严重度分级（阻断/高/中/低）；修复需附对应自动化回归用例。

## 12. 测试数据与基线

- 数据集：提供合成样本；保证可公开共享与稳定复现。
- 随机性：统一随机种子；基准函数与超参数的基线配置保存在版本库。
- 目录建议：tests/unit、tests/integration、tests/e2e、tests/perf；慢测试加标记，默认跳过。

——
本规范提炼自原 technical_specifications.md 中“精度验证与质量保证”等相关内容，并结合工程化质量门禁要求统一到 CI/CD 流水线中执行。
