# 水泵数据处理技术规范

## 🔧 如何使用本规范

1. 数据处理快速上手：选择曲线类型 → 数据预处理与质量控制 → 选择拟合方法 → 验证精度（R² ≥ 0.95）。
1. 代码复用：所有代码块可独立运行，直接复制到项目中即可使用；注意numpy/pandas/scipy依赖。
1. 质量标准：遵循物理约束验证 → 单调性检查 → 异常值处理 → 单位转换与归一化的标准流程。
1. 扩展适配：新设备类型参考"数据扩展适应性设计"；新传感器数据格式参考"多格式数据解析器"。

版本：v1.0 | 适用范围：CSV数据导入、特性曲线拟合、数据质量控制、额定参数计算

## 目录

1. [数据结构分析](#1-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%88%86%E6%9E%90)
1. [特性曲线拟合技术规范](#2-%E7%89%B9%E6%80%A7%E6%9B%B2%E7%BA%BF%E6%8B%9F%E5%90%88%E6%8A%80%E6%9C%AF%E8%A7%84%E8%8C%83)
1. [数据预处理与质量控制](#3-%E6%95%B0%E6%8D%AE%E9%A2%84%E5%A4%84%E7%90%86%E4%B8%8E%E8%B4%A8%E9%87%8F%E6%8E%A7%E5%88%B6)
1. [数据补齐技术规范](#4-%E6%95%B0%E6%8D%AE%E8%A1%A5%E9%BD%90%E6%8A%80%E6%9C%AF%E8%A7%84%E8%8C%83)
1. [泵额定参数计算规范](#5-%E6%B3%B5%E9%A2%9D%E5%AE%9A%E5%8F%82%E6%95%B0%E8%AE%A1%E7%AE%97%E8%A7%84%E8%8C%83)
1. [数据扩展适应性设计](#6-%E6%95%B0%E6%8D%AE%E6%89%A9%E5%B1%95%E9%80%82%E5%BA%94%E6%80%A7%E8%AE%BE%E8%AE%A1)

______________________________________________________________________

## 1. 数据结构分析

### 1.1 设备分类

根据需求分析，系统需处理以下水泵设备类型：

#### 1.1.1 按泵类型分类

- **离心泵**: 单级、多级、双吸、导叶式
- **轴流泵**: 立式、卧式、混流式
- **往复泵**: 柱塞泵、隔膜泵
- **转子泵**: 齿轮泵、螺杆泵、罗茨泵
- **特殊泵**: 磁力泵、屏蔽泵、液环泵

#### 1.1.2 按驱动方式分类

- **电机驱动**: 直联、联轴器连接、皮带传动
- **变频驱动**: 变频器控制的电机泵组
- **软启动**: 软启动器控制的泵组

### 1.2 数据格式规范

#### 1.2.1 CSV文件格式

```python
# 实际CSV文件结构（基于data目录下的文件格式）
REQUIRED_COLUMNS = {
    'TagName': '标签名称/传感器标识',
    'DataTime': '数据时间戳',
    'DataVersion': '数据版本',
    'DataQuality': '数据质量标识',
    'DataValue': '数据值'
}

# CSV文件命名规范（基于实际文件）
FILE_NAMING_PATTERN = {
    'format': '_{期数}_{泵房类型}_{设备编号}_{物理量}_{反馈类型}.csv',
    'examples': [
        '_一期_供水泵房_1#加压泵_有功功率_反馈.csv',
        '_二期_供水泵房_1#加压泵_振动A_反馈.csv',
        '二期_供水泵房_多功能电表_1#加压泵_A相电压_反馈.csv'
    ]
}

# 支持的物理量类型
PHYSICAL_QUANTITIES = {
    'electrical': ['有功功率', 'A相有功功率', 'B相有功功率', 'C相有功功率',
                   'Ia', 'Ib', 'Ic', 'Ua', 'Ub', 'Uc', '功率因数',
                   '正向有功电能', '无功功率', '频率'],
    'hydraulic': ['出口压力', '瞬时流量', '累计流量', '正向累计流量'],
    'mechanical': ['振动A', '振动B', '温度_通道1', '温度_通道2',
                   '温度_通道3', '温度_通道4', '温度_通道5',
                   '温度_通道6', '温度_通道7', '温度_通道8']
}
```

#### 1.2.2 数据约束条件

```python
# 基于实际CSV文件格式的数据约束
DATA_CONSTRAINTS = {
    'TagName': {'type': 'string', 'required': True, 'description': '传感器标识符'},
    'DataTime': {'type': 'datetime', 'required': True, 'format': 'YYYY-MM-DD HH:MM:SS'},
    'DataVersion': {'type': 'string', 'required': True, 'description': '数据版本标识'},
    'DataQuality': {'type': 'string', 'required': True, 'description': '数据质量标识'},
    'DataValue': {'type': 'float', 'required': True, 'description': '实际测量值'}
}

# 物理量数值范围约束
PHYSICAL_VALUE_CONSTRAINTS = {
    '有功功率': {'min': 0, 'max': 5000, 'unit': 'kW'},
    '电流': {'min': 0, 'max': 1000, 'unit': 'A'},
    '电压': {'min': 0, 'max': 500, 'unit': 'V'},
    '压力': {'min': 0, 'max': 50, 'unit': 'bar'},
    '流量': {'min': 0, 'max': 10000, 'unit': 'm³/h'},
    '频率': {'min': 0, 'max': 100, 'unit': 'Hz'},
    '振动': {'min': 0, 'max': 100, 'unit': 'mm/s'},
    '温度': {'min': -50, 'max': 200, 'unit': '°C'},
    '功率因数': {'min': 0, 'max': 1, 'unit': '无量纲'},
    '电能': {'min': 0, 'max': 999999999, 'unit': 'kWh'}
}
```

______________________________________________________________________

## 2. 特性曲线拟合技术规范

### 2.1 拟合目标

根据需求分析，系统需要拟合以下特性曲线：

#### 2.1.1 基础水力特性曲线

- **扬程-流量曲线** (H-Q): H = f(Q)，精度要求 R² ≥ 0.95
- **效率-流量曲线** (η-Q): η = f(Q)，精度要求 R² ≥ 0.92
- **功率-流量曲线** (P-Q): P = f(Q)，精度要求 R² ≥ 0.90
- **NPSH-流量曲线**: NPSH = f(Q)，精度要求 R² ≥ 0.85
- **扭矩-流量曲线** (T-Q): T = f(Q)，精度要求 R² ≥ 0.88
- **轴功率-转速曲线** (P-n): P = f(n)，精度要求 R² ≥ 0.93

#### 2.1.2 电气特性曲线

- **电流-流量曲线** (I-Q): I = f(Q)，考虑负载变化
- **电压-负载曲线** (U-Load): U = f(Load)，电压降分析
- **功率因数-负载曲线** (cosφ-Load): cosφ = f(Load)
- **频率-转速曲线** (f-n): n = f(f)，变频控制关系
- **电能消耗-流量曲线** (E-Q): E = f(Q)，能耗效率分析

#### 2.1.3 振动与控制特性曲线

- **振动-转速曲线** (V-n): V = f(n)，振动幅度分析
- **振动-流量曲线** (V-Q): V = f(Q)，工况点振动

#### 2.1.4 变频泵特性曲线

- **变频扬程曲线**: H = f(Q, n)，三维曲面拟合
- **变频功率曲线**: P = f(Q, n)，包含变频器效率
- **变频效率曲线**: η = f(Q, n)，修正模型
- **变频谐波特性**: THD = f(frequency)

#### 2.1.5 软启泵特性曲线

- **启动特性曲线**: 转矩-时间、电流-时间动态特性
- **运行特性曲线**: 标准单泵特性
- **启动电流曲线**: I_start = f(t)，软启动电流变化
- **启动扭矩曲线**: T_start = f(t)，启动过程扭矩

#### 2.1.6 泵组特性曲线

- **并联运行曲线**: H_group = f(Q_total, n_pumps)
- **串联运行曲线**: H_total = f(Q, n_pumps)
- **组合效率曲线**: η_group = f(Q_total, combination)
- **负载分配特性**: Load_distribution = f(pump_combination)

### 2.2 拟合方法体系

#### 2.2.1 物理拟合方法

##### 2.2.1.1 欧拉方程拟合法

```python
import numpy as np

class EulerEquationFitter:
    """
    基于欧拉方程的物理拟合器
    """

    def __init__(self, impeller_diameter, rated_speed):
        self.D = impeller_diameter  # 叶轮直径 (m)
        self.n_rated = rated_speed  # 额定转速 (r/min)
        self.coefficients = None

    def fit(self, Q, H, n=None):
        """
        基于欧拉方程拟合
        H_th = A * u2^2 / g - B * Q^2
        """
        if n is None:
            n = self.n_rated

        # 计算叶轮出口圆周速度
        u2 = np.pi * self.D * n / 60  # m/s

        # 构建拟合矩阵
        # H = A * u2^2 / 9.81 - B * Q^2
        X = np.column_stack([np.ones(len(Q)) * u2**2 / 9.81, -Q**2])

        # 最小二乘拟合
        self.coefficients = np.linalg.lstsq(X, H, rcond=None)[0]

        return {
            'A': self.coefficients[0],  # 叶轮效率系数
            'B': self.coefficients[1],  # 流动损失系数
            'theoretical_head': self.coefficients[0] * u2**2 / 9.81
        }

    def predict(self, Q, n=None):
        """
        预测扬程
        """
        if n is None:
            n = self.n_rated

        u2 = np.pi * self.D * n / 60
        A, B = self.coefficients

        return A * u2**2 / 9.81 - B * Q**2
```

##### 2.2.1.2 相似定律拟合法

```python
import numpy as np

class SimilarityLawFitter:
    """
    基于相似定律的拟合器
    """

    def __init__(self, rated_params):
        self.Q_rated = rated_params['flow']      # 额定流量
        self.H_rated = rated_params['head']      # 额定扬程
        self.n_rated = rated_params['speed']     # 额定转速
        self.base_curve = None

    def fit(self, Q, H, n):
        """
        基于相似定律拟合多转速特性
        """
        # 无量纲化处理
        Q_norm = Q / (n / self.n_rated)
        H_norm = H / (n / self.n_rated)**2

        # 拟合无量纲特性曲线
        self.base_curve = np.polyfit(Q_norm, H_norm, 2)

        return {
            'base_coefficients': self.base_curve,
            'similarity_law_valid': self._validate_similarity_law(Q, H, n)
        }

    def predict(self, Q, n):
        """
        基于相似定律预测不同转速下的扬程
        """
        # 转换到基准转速
        Q_base = Q / (n / self.n_rated)
        H_base = np.polyval(self.base_curve, Q_base)

        # 转换回实际转速
        return H_base * (n / self.n_rated)**2

    def _validate_similarity_law(self, Q, H, n):
        """
        验证相似定律的适用性
        """
        predicted_H = self.predict(Q, n)
        r2 = 1 - np.sum((H - predicted_H)**2) / np.sum((H - np.mean(H))**2)
        return r2 > 0.95
```

##### 2.2.1.3 比转速拟合法

```python
import numpy as np

class SpecificSpeedFitter:
    """
    基于比转速的拟合器
    """

    def __init__(self):
        self.ns = None  # 比转速
        self.efficiency_model = None

    def fit(self, Q, H, P, n):
        """
        基于比转速拟合效率特性
        """
        # 计算比转速
        Q_m3s = Q / 3600  # 转换为 m³/s
        self.ns = n * np.sqrt(Q_m3s) / (H**(3/4))

        # 计算效率
        efficiency = (1000 * 9.81 * Q_m3s * H) / (P * 1000)  # 水力效率

        # 基于比转速的效率模型
        # η = η_max * f(Q/Q_opt)
        Q_opt = Q[np.argmax(efficiency)]
        Q_ratio = Q / Q_opt

        # 拟合效率曲线
        self.efficiency_model = np.polyfit(Q_ratio, efficiency, 3)

        return {
            'specific_speed': np.mean(self.ns),
            'optimal_flow': Q_opt,
            'max_efficiency': np.max(efficiency),
            'pump_type': self._classify_pump_type(np.mean(self.ns))
        }

    def predict_efficiency(self, Q, Q_opt):
        """
        基于比转速预测效率
        """
        Q_ratio = Q / Q_opt
        return np.polyval(self.efficiency_model, Q_ratio)

    def _classify_pump_type(self, ns):
        """
        根据比转速分类泵型
        """
        if ns < 150:
            return '离心泵'
        elif ns < 500:
            return '混流泵'
        else:
            return '轴流泵'
```

#### 2.2.2 传统数学方法

##### 2.2.2.1 多项式拟合法

```python
import numpy as np

class PolynomialFitter:
    """
    多项式拟合器
    """

    def __init__(self, degree=2):
        self.degree = degree
        self.coefficients = None

    def fit(self, Q, H):
        """
        多项式拟合
        """
        # 标准二次多项式：H = a*Q² + b*Q + c
        self.coefficients = np.polyfit(Q, H, self.degree)
        return self.coefficients

    def predict(self, Q):
        """
        预测扬程
        """
        return np.polyval(self.coefficients, Q)

    def get_optimal_flow(self):
        """
        获取最优流量点（效率最高点）
        """
        if self.degree == 2:
            a, b, c = self.coefficients
            Q_opt = -b / (2 * a)
            return Q_opt
        return None

# 分段多项式拟合
import numpy as np

class PiecewisePolynomialFitter:
    """
    分段多项式拟合器
    """

    def __init__(self, breakpoints=None):
        self.breakpoints = breakpoints
        self.segment_fitters = []

    def fit(self, Q, H):
        """
        分段拟合
        """
        if self.breakpoints is None:
            # 自动确定分段点
            self.breakpoints = self._find_optimal_breakpoints(Q, H)

        # 为每个段拟合多项式
        for i in range(len(self.breakpoints) + 1):
            if i == 0:
                mask = Q <= self.breakpoints[0]
            elif i == len(self.breakpoints):
                mask = Q >= self.breakpoints[-1]
            else:
                mask = (Q >= self.breakpoints[i-1]) & (Q <= self.breakpoints[i])

            if np.sum(mask) > 2:
                fitter = PolynomialFitter(degree=2)
                fitter.fit(Q[mask], H[mask])
                self.segment_fitters.append(fitter)
```

##### 2.2.2.2 样条插值法

```python
from scipy.interpolate import CubicSpline, UnivariateSpline, BSpline

class SplineFitter:
    """
    样条插值拟合器
    """

    def __init__(self, spline_type='cubic'):
        self.spline_type = spline_type
        self.spline_func = None

    def fit(self, Q, H, smoothing=None):
        """
        样条拟合
        """
        if self.spline_type == 'cubic':
            # 三次样条插值
            self.spline_func = CubicSpline(Q, H, bc_type='natural')
        elif self.spline_type == 'univariate':
            # 单变量样条（可调节平滑度）
            s = smoothing if smoothing else len(Q)
            self.spline_func = UnivariateSpline(Q, H, s=s)
        elif self.spline_type == 'bspline':
            # B样条
            from scipy.interpolate import splrep, BSpline
            tck = splrep(Q, H, s=smoothing)
            self.spline_func = BSpline(*tck)

    def predict(self, Q):
        """
        预测扬程
        """
        return self.spline_func(Q)

    def get_derivative(self, Q, order=1):
        """
        获取导数（用于分析曲线特性）
        """
        return self.spline_func.derivative(order)(Q)
```

______________________________________________________________________

## 3. 数据预处理与质量控制

### 3.1 数据清洗规范

#### 3.1.1 异常值检测

```python
import numpy as np

class OutlierDetector:
    """
    异常值检测器
    """

    def __init__(self, method='iqr'):
        self.method = method
        self.fitted_params = {}

    def detect_outliers(self, data, column):
        """
        检测异常值
        """
        if self.method == 'iqr':
            return self._iqr_outliers(data[column])
        elif self.method == 'zscore':
            return self._zscore_outliers(data[column])
        elif self.method == 'isolation_forest':
            return self._isolation_forest_outliers(data[column])

    def _iqr_outliers(self, series):
        """
        基于四分位距的异常值检测
        """
        Q1 = series.quantile(0.25)
        Q3 = series.quantile(0.75)
        IQR = Q3 - Q1

        lower_bound = Q1 - 1.5 * IQR
        upper_bound = Q3 + 1.5 * IQR

        return (series < lower_bound) | (series > upper_bound)

    def _zscore_outliers(self, series, threshold=3):
        """
        基于Z-score的异常值检测
        """
        import numpy as np
        z_scores = np.abs((series - series.mean()) / series.std())
        return z_scores > threshold

    def _isolation_forest_outliers(self, series):
        """
        基于孤立森林的异常值检测
        """
        from sklearn.ensemble import IsolationForest

        iso_forest = IsolationForest(contamination=0.1, random_state=42)
        outliers = iso_forest.fit_predict(series.values.reshape(-1, 1))

        return outliers == -1
```

#### 3.1.2 缺失值处理

```python
class MissingValueHandler:
    """
    缺失值处理器
    """

    def __init__(self):
        self.imputation_strategy = {}

    def handle_missing_values(self, data, strategy='interpolation'):
        """
        处理缺失值
        """
        if strategy == 'interpolation':
            return self._interpolation_imputation(data)
        elif strategy == 'forward_fill':
            return data.fillna(method='ffill')
        elif strategy == 'backward_fill':
            return data.fillna(method='bfill')
        elif strategy == 'mean':
            return data.fillna(data.mean())
        elif strategy == 'median':
            return data.fillna(data.median())

    def _interpolation_imputation(self, data):
        """
        基于插值的缺失值填充
        """
        # 对于特性曲线数据，使用线性插值
        for column in ['Q', 'H', 'P', 'eta']:
            if column in data.columns:
                data[column] = data[column].interpolate(method='linear')

        return data
```

### 3.2 数据验证规范

#### 3.2.1 物理约束验证

```python
import numpy as np

class PhysicalConstraintValidator:
    """
    物理约束验证器
    """

    def __init__(self):
        self.constraints = {
            'Q': {'min': 0, 'max': 10000, 'type': 'positive'},
            'H': {'min': 0, 'max': 1000, 'type': 'positive'},
            'P': {'min': 0, 'max': 5000, 'type': 'positive'},
            'eta': {'min': 0, 'max': 100, 'type': 'percentage'},
            'n': {'min': 0, 'max': 10000, 'type': 'positive'}
        }

    def validate_constraints(self, data):
        """
        验证物理约束
        """
        violations = {}

        for column, constraint in self.constraints.items():
            if column in data.columns:
                # 范围检查
                out_of_range = (data[column] < constraint['min']) | \
                              (data[column] > constraint['max'])

                if out_of_range.any():
                    violations[column] = {
                        'type': 'range_violation',
                        'count': out_of_range.sum(),
                        'indices': data[out_of_range].index.tolist()
                    }

                # 物理合理性检查
                if constraint['type'] == 'positive':
                    negative_values = data[column] < 0
                    if negative_values.any():
                        violations[f'{column}_negative'] = {
                            'type': 'physical_violation',
                            'count': negative_values.sum(),
                            'indices': data[negative_values].index.tolist()
                        }

        return violations

    def validate_curve_monotonicity(self, Q, H):
        """
        验证扬程曲线的单调性
        """
        import numpy as np
        # 扬程曲线应该随流量增加而下降
        dH_dQ = np.diff(H) / np.diff(Q)

        # 允许小幅上升（考虑测量误差）
        tolerance = 0.05  # 5%容差
        non_monotonic = dH_dQ > tolerance * np.mean(H)

        return {
            'is_monotonic': not non_monotonic.any(),
            'violation_count': non_monotonic.sum(),
            'violation_points': np.where(non_monotonic)[0]
        }
```

### 3.3 数据标准化

#### 3.3.1 单位转换

```python
class UnitConverter:
    """
    单位转换器
    """

    def __init__(self):
        self.conversion_factors = {
            'flow': {
                'm³/h': 1.0,
                'm³/s': 3600.0,
                'L/min': 1/60.0,
                'L/s': 1.0,
                'gpm': 0.227125  # 美制加仑/分钟
            },
            'head': {
                'm': 1.0,
                'ft': 0.3048,
                'mbar': 0.0102,
                'psi': 0.7031
            },
            'power': {
                'kW': 1.0,
                'hp': 0.746,
                'W': 0.001
            }
        }

    def convert_units(self, data, unit_mapping):
        """
        转换单位
        unit_mapping: {'column': {'from': 'unit1', 'to': 'unit2'}}
        """
        converted_data = data.copy()

        for column, units in unit_mapping.items():
            if column in data.columns:
                from_unit = units['from']
                to_unit = units['to']

                # 获取转换系数
                if column in ['Q', 'flow']:
                    factor = self.conversion_factors['flow'][from_unit] / \
                            self.conversion_factors['flow'][to_unit]
                elif column in ['H', 'head']:
                    factor = self.conversion_factors['head'][from_unit] / \
                            self.conversion_factors['head'][to_unit]
                elif column in ['P', 'power']:
                    factor = self.conversion_factors['power'][from_unit] / \
                            self.conversion_factors['power'][to_unit]

                converted_data[column] = data[column] * factor

        return converted_data
```

#### 3.3.2 数据归一化

```python
class DataNormalizer:
    """
    数据归一化器
    """

    def __init__(self, method='minmax'):
        self.method = method
        self.scaler_params = {}

    def fit_transform(self, data, columns=None):
        """
        拟合并转换数据
        """
        if columns is None:
            columns = data.select_dtypes(include=[np.number]).columns

        normalized_data = data.copy()

        for column in columns:
            if self.method == 'minmax':
                min_val = data[column].min()
                max_val = data[column].max()

                self.scaler_params[column] = {'min': min_val, 'max': max_val}
                normalized_data[column] = (data[column] - min_val) / (max_val - min_val)

            elif self.method == 'zscore':
                mean_val = data[column].mean()
                std_val = data[column].std()

                self.scaler_params[column] = {'mean': mean_val, 'std': std_val}
                normalized_data[column] = (data[column] - mean_val) / std_val

        return normalized_data

    def inverse_transform(self, normalized_data, columns=None):
        """
        反向转换数据
        """
        if columns is None:
            columns = self.scaler_params.keys()

        original_data = normalized_data.copy()

        for column in columns:
            if column in self.scaler_params:
                params = self.scaler_params[column]

                if self.method == 'minmax':
                    original_data[column] = normalized_data[column] * \
                                          (params['max'] - params['min']) + params['min']
                elif self.method == 'zscore':
                    original_data[column] = normalized_data[column] * \
                                          params['std'] + params['mean']

        return original_data
```

______________________________________________________________________

## 4. 数据补齐技术规范

### 4.1 插值补齐方法

#### 4.1.1 线性插值

```python
class LinearInterpolator:
    """
    线性插值器
    """

    def interpolate(self, Q_known, H_known, Q_target):
        """
        线性插值
        """
        from scipy.interpolate import interp1d

        # 创建插值函数
        f = interp1d(Q_known, H_known, kind='linear',
                    bounds_error=False, fill_value='extrapolate')

        return f(Q_target)
```

#### 4.1.2 样条插值

```python
class SplineInterpolator:
    """
    样条插值器
    """

    def interpolate(self, Q_known, H_known, Q_target, order=3):
        """
        样条插值
        """
        from scipy.interpolate import UnivariateSpline

        # 创建样条函数
        spline = UnivariateSpline(Q_known, H_known, k=order, s=0)

        return spline(Q_target)
```

### 4.2 基于物理模型的补齐

### 4.3 机器学习补齐方法

#### 4.3.1 回归模型补齐

```python
class MLBasedFiller:
    """
    基于机器学习的数据补齐器
    """

    def __init__(self, model_type='random_forest'):
        self.model_type = model_type
        self.model = None

    def fit_and_fill(self, data, target_column, feature_columns):
        """
        训练模型并补齐数据
        """
        from sklearn.ensemble import RandomForestRegressor
        from sklearn.linear_model import LinearRegression

        # 分离已知和未知数据
        known_mask = data[target_column].notna()
        X_known = data.loc[known_mask, feature_columns]
        y_known = data.loc[known_mask, target_column]
        X_unknown = data.loc[~known_mask, feature_columns]

        # 选择模型
        if self.model_type == 'random_forest':
            self.model = RandomForestRegressor(n_estimators=100, random_state=42)
        elif self.model_type == 'linear':
            self.model = LinearRegression()

        # 训练模型
        self.model.fit(X_known, y_known)

        # 预测缺失值
        y_predicted = self.model.predict(X_unknown)

        # 填充数据
        filled_data = data.copy()
        filled_data.loc[~known_mask, target_column] = y_predicted

        return filled_data
```

______________________________________________________________________

## 5. 泵额定参数计算规范

### 5.1 额定工况点确定

#### 5.1.1 最优效率点计算

```python
class RatedPointCalculator:
    """
    额定工况点计算器
    """

    def find_optimal_efficiency_point(self, Q_data, eta_data):
        """
        找到最优效率点
        """
        max_eta_idx = np.argmax(eta_data)
        Q_opt = Q_data[max_eta_idx]
        eta_opt = eta_data[max_eta_idx]

        return {
            'Q_opt': Q_opt,
            'eta_opt': eta_opt,
            'index': max_eta_idx
        }

    def calculate_rated_parameters(self, pump_data):
        """
        计算额定参数
        """
        # 找到最优效率点
        opt_point = self.find_optimal_efficiency_point(
            pump_data['Q'], pump_data['eta']
        )

        Q_rated = opt_point['Q_opt']
        idx = opt_point['index']

        rated_params = {
            'Q_rated': Q_rated,
            'H_rated': pump_data['H'].iloc[idx],
            'P_rated': pump_data['P'].iloc[idx],
            'eta_rated': opt_point['eta_opt'],
            'n_rated': pump_data['n'].iloc[idx]
        }

        return rated_params
```

### 5.2 性能曲线特征点计算

#### 5.2.1 关键工况点识别

```python
class PerformancePointCalculator:
    """
    性能特征点计算器
    """

    def calculate_characteristic_points(self, Q_data, H_data, P_data, eta_data):
        """
        计算特性曲线关键点
        """
        characteristic_points = {}

        # 1. 最大扬程点（Q=0时的扬程）
        H_max_idx = np.argmin(Q_data)  # 最小流量点
        characteristic_points['shutoff'] = {
            'Q': Q_data[H_max_idx],
            'H': H_data[H_max_idx],
            'description': '关闭点扬程'
        }

        # 2. 最大效率点
        eta_max_idx = np.argmax(eta_data)
        characteristic_points['BEP'] = {  # Best Efficiency Point
            'Q': Q_data[eta_max_idx],
            'H': H_data[eta_max_idx],
            'P': P_data[eta_max_idx],
            'eta': eta_data[eta_max_idx],
            'description': '最优效率点'
        }

        # 3. 设计点（通常为最优效率点的80-120%流量范围）
        Q_bep = Q_data[eta_max_idx]
        design_range_mask = (Q_data >= 0.8 * Q_bep) & (Q_data <= 1.2 * Q_bep)

        if design_range_mask.any():
            design_eta_avg = eta_data[design_range_mask].mean()
            characteristic_points['design_range'] = {
                'Q_min': 0.8 * Q_bep,
                'Q_max': 1.2 * Q_bep,
                'eta_avg': design_eta_avg,
                'description': '设计范围'
            }

        # 4. 最大流量点
        Q_max_idx = np.argmax(Q_data)
        characteristic_points['max_flow'] = {
            'Q': Q_data[Q_max_idx],
            'H': H_data[Q_max_idx],
            'eta': eta_data[Q_max_idx],
            'description': '最大流量点'
        }

        return characteristic_points
```

______________________________________________________________________

## 6. 数据扩展适应性设计

### 6.1 新设备类型适配

### 6.2 动态拟合参数调整

#### 6.2.1 自适应拟合策略

```python
class AdaptiveFittingStrategy:
    """
    自适应拟合策略
    """

    def __init__(self):
        self.fitting_methods = [
            'polynomial',
            'spline',
            'physical_model',
            'hybrid'
        ]
        self.performance_threshold = 0.95  # R²阈值

    def select_best_method(self, Q_data, H_data, pump_type=None):
        """
        选择最佳拟合方法
        """
        best_method = None
        best_score = 0
        best_params = None

        for method in self.fitting_methods:
            try:
                score, params = self._evaluate_method(method, Q_data, H_data, pump_type)

                if score > best_score:
                    best_score = score
                    best_method = method
                    best_params = params

            except Exception as e:
                logger.warning(f"拟合方法 {method} 失败: {e}")
                continue

        return {
            'method': best_method,
            'score': best_score,
            'parameters': best_params,
            'meets_threshold': best_score >= self.performance_threshold
        }

    def _evaluate_method(self, method, Q_data, H_data, pump_type):
        """
        评估拟合方法性能
        """
        if method == 'polynomial':
            return self._evaluate_polynomial(Q_data, H_data)
        elif method == 'spline':
            return self._evaluate_spline(Q_data, H_data)
        elif method == 'physical_model':
            return self._evaluate_physical_model(Q_data, H_data, pump_type)
        elif method == 'hybrid':
            return self._evaluate_hybrid(Q_data, H_data, pump_type)

    def _evaluate_polynomial(self, Q_data, H_data):
        """
        评估多项式拟合
        """
        import numpy as np
        from sklearn.metrics import r2_score

        # 尝试不同阶数
        best_score = 0
        best_degree = 2

        for degree in [2, 3, 4]:
            coeffs = np.polyfit(Q_data, H_data, degree)
            H_pred = np.polyval(coeffs, Q_data)
            score = r2_score(H_data, H_pred)

            if score > best_score:
                best_score = score
                best_degree = degree

        return best_score, {'degree': best_degree}
```

### 6.3 数据格式扩展支持

#### 6.3.1 多格式数据解析器

```python
class DataFormatParser:
    """
    多格式数据解析器
    """

    def __init__(self):
        self.supported_formats = ['csv', 'excel', 'json', 'xml', 'database']
        self.column_mappings = {}

    def parse_data(self, file_path, format_type=None):
        """
        解析多种格式的数据文件
        """
        if format_type is None:
            format_type = self._detect_format(file_path)

        if format_type == 'csv':
            return self._parse_csv(file_path)
        elif format_type == 'excel':
            return self._parse_excel(file_path)
        elif format_type == 'json':
            return self._parse_json(file_path)
        elif format_type == 'xml':
            return self._parse_xml(file_path)
        else:
            raise ValueError(f"不支持的文件格式: {format_type}")

    def _detect_format(self, file_path):
        """
        自动检测文件格式
        """
        file_extension = file_path.split('.')[-1].lower()

        format_map = {
            'csv': 'csv',
            'xlsx': 'excel',
            'xls': 'excel',
            'json': 'json',
            'xml': 'xml'
        }

        return format_map.get(file_extension, 'unknown')

    def _parse_csv(self, file_path):
        """
        解析CSV文件
        """
        import pandas as pd  # 局部导入，避免未使用时的环境依赖
        # 尝试不同的分隔符和编码
        separators = [',', ';', '\t']
        encodings = ['utf-8', 'gbk', 'latin-1']

        for sep in separators:
            for encoding in encodings:
                try:
                    data = pd.read_csv(file_path, sep=sep, encoding=encoding)
                    if len(data.columns) > 1:  # 成功解析
                        return self._standardize_columns(data)
                except:
                    continue

        raise ValueError("无法解析CSV文件")

    def _standardize_columns(self, data):
        """
        标准化列名
        """
        column_aliases = {
            'flow': ['Q', 'Flow', '流量', 'flow_rate'],
            'head': ['H', 'Head', '扬程', 'head'],
            'power': ['P', 'Power', '功率', 'power'],
            'efficiency': ['eta', 'Efficiency', '效率', 'eff'],
            'speed': ['n', 'Speed', '转速', 'rpm']
        }

        standardized_data = data.copy()

        for standard_name, aliases in column_aliases.items():
            for alias in aliases:
                if alias in data.columns:
                    standardized_data.rename(columns={alias: standard_name}, inplace=True)
                    break

        return standardized_data
```

______________________________________________________________________

## 总结

本文档定义了水泵数据处理的完整技术规范，包括：

1. **数据结构分析**: 明确了设备分类和数据格式要求
1. **特性曲线拟合**: 提供了物理模型和数学方法的完整拟合体系
1. **数据预处理**: 建立了数据清洗、验证和标准化流程
1. **数据补齐**: 定义了多种插值和模型补齐方法
1. **额定参数计算**: 规范了关键性能点的识别和计算
1. **扩展适应性**: 提供了新设备类型和数据格式的适配机制

这些规范确保了系统能够处理各种类型的水泵数据，并提供高质量的特性曲线拟合结果。
